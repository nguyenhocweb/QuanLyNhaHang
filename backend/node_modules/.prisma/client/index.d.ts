
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Brands
 * 
 */
export type Brands = $Result.DefaultSelection<Prisma.$BrandsPayload>
/**
 * Model Owners_Brand
 * 
 */
export type Owners_Brand = $Result.DefaultSelection<Prisma.$Owners_BrandPayload>
/**
 * Model Roles_Admin
 * 
 */
export type Roles_Admin = $Result.DefaultSelection<Prisma.$Roles_AdminPayload>
/**
 * Model Roles_KhachHang
 * 
 */
export type Roles_KhachHang = $Result.DefaultSelection<Prisma.$Roles_KhachHangPayload>
/**
 * Model Roles_Staff
 * 
 */
export type Roles_Staff = $Result.DefaultSelection<Prisma.$Roles_StaffPayload>
/**
 * Model Users_Admin
 * 
 */
export type Users_Admin = $Result.DefaultSelection<Prisma.$Users_AdminPayload>
/**
 * Model Users_KhachHang
 * 
 */
export type Users_KhachHang = $Result.DefaultSelection<Prisma.$Users_KhachHangPayload>
/**
 * Model Users_Staff
 * 
 */
export type Users_Staff = $Result.DefaultSelection<Prisma.$Users_StaffPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Status_Brand: {
  HOAT_DONG: 'HOAT_DONG',
  NGUNG_HOAT_DONG: 'NGUNG_HOAT_DONG'
};

export type Status_Brand = (typeof Status_Brand)[keyof typeof Status_Brand]


export const Gender: {
  NAM: 'NAM',
  NU: 'NU',
  KHAC: 'KHAC'
};

export type Gender = (typeof Gender)[keyof typeof Gender]

}

export type Status_Brand = $Enums.Status_Brand

export const Status_Brand: typeof $Enums.Status_Brand

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Brands
 * const brands = await prisma.brands.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Brands
   * const brands = await prisma.brands.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.brands`: Exposes CRUD operations for the **Brands** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brands.findMany()
    * ```
    */
  get brands(): Prisma.BrandsDelegate<ExtArgs>;

  /**
   * `prisma.owners_Brand`: Exposes CRUD operations for the **Owners_Brand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Owners_Brands
    * const owners_Brands = await prisma.owners_Brand.findMany()
    * ```
    */
  get owners_Brand(): Prisma.Owners_BrandDelegate<ExtArgs>;

  /**
   * `prisma.roles_Admin`: Exposes CRUD operations for the **Roles_Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles_Admins
    * const roles_Admins = await prisma.roles_Admin.findMany()
    * ```
    */
  get roles_Admin(): Prisma.Roles_AdminDelegate<ExtArgs>;

  /**
   * `prisma.roles_KhachHang`: Exposes CRUD operations for the **Roles_KhachHang** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles_KhachHangs
    * const roles_KhachHangs = await prisma.roles_KhachHang.findMany()
    * ```
    */
  get roles_KhachHang(): Prisma.Roles_KhachHangDelegate<ExtArgs>;

  /**
   * `prisma.roles_Staff`: Exposes CRUD operations for the **Roles_Staff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles_Staffs
    * const roles_Staffs = await prisma.roles_Staff.findMany()
    * ```
    */
  get roles_Staff(): Prisma.Roles_StaffDelegate<ExtArgs>;

  /**
   * `prisma.users_Admin`: Exposes CRUD operations for the **Users_Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users_Admins
    * const users_Admins = await prisma.users_Admin.findMany()
    * ```
    */
  get users_Admin(): Prisma.Users_AdminDelegate<ExtArgs>;

  /**
   * `prisma.users_KhachHang`: Exposes CRUD operations for the **Users_KhachHang** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users_KhachHangs
    * const users_KhachHangs = await prisma.users_KhachHang.findMany()
    * ```
    */
  get users_KhachHang(): Prisma.Users_KhachHangDelegate<ExtArgs>;

  /**
   * `prisma.users_Staff`: Exposes CRUD operations for the **Users_Staff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users_Staffs
    * const users_Staffs = await prisma.users_Staff.findMany()
    * ```
    */
  get users_Staff(): Prisma.Users_StaffDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Brands: 'Brands',
    Owners_Brand: 'Owners_Brand',
    Roles_Admin: 'Roles_Admin',
    Roles_KhachHang: 'Roles_KhachHang',
    Roles_Staff: 'Roles_Staff',
    Users_Admin: 'Users_Admin',
    Users_KhachHang: 'Users_KhachHang',
    Users_Staff: 'Users_Staff'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "brands" | "owners_Brand" | "roles_Admin" | "roles_KhachHang" | "roles_Staff" | "users_Admin" | "users_KhachHang" | "users_Staff"
      txIsolationLevel: never
    }
    model: {
      Brands: {
        payload: Prisma.$BrandsPayload<ExtArgs>
        fields: Prisma.BrandsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrandsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrandsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandsPayload>
          }
          findFirst: {
            args: Prisma.BrandsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrandsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandsPayload>
          }
          findMany: {
            args: Prisma.BrandsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandsPayload>[]
          }
          create: {
            args: Prisma.BrandsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandsPayload>
          }
          createMany: {
            args: Prisma.BrandsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BrandsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandsPayload>
          }
          update: {
            args: Prisma.BrandsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandsPayload>
          }
          deleteMany: {
            args: Prisma.BrandsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BrandsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BrandsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandsPayload>
          }
          aggregate: {
            args: Prisma.BrandsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrands>
          }
          groupBy: {
            args: Prisma.BrandsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrandsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BrandsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BrandsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BrandsCountArgs<ExtArgs>
            result: $Utils.Optional<BrandsCountAggregateOutputType> | number
          }
        }
      }
      Owners_Brand: {
        payload: Prisma.$Owners_BrandPayload<ExtArgs>
        fields: Prisma.Owners_BrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Owners_BrandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Owners_BrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Owners_BrandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Owners_BrandPayload>
          }
          findFirst: {
            args: Prisma.Owners_BrandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Owners_BrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Owners_BrandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Owners_BrandPayload>
          }
          findMany: {
            args: Prisma.Owners_BrandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Owners_BrandPayload>[]
          }
          create: {
            args: Prisma.Owners_BrandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Owners_BrandPayload>
          }
          createMany: {
            args: Prisma.Owners_BrandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Owners_BrandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Owners_BrandPayload>
          }
          update: {
            args: Prisma.Owners_BrandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Owners_BrandPayload>
          }
          deleteMany: {
            args: Prisma.Owners_BrandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Owners_BrandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Owners_BrandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Owners_BrandPayload>
          }
          aggregate: {
            args: Prisma.Owners_BrandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOwners_Brand>
          }
          groupBy: {
            args: Prisma.Owners_BrandGroupByArgs<ExtArgs>
            result: $Utils.Optional<Owners_BrandGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.Owners_BrandFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.Owners_BrandAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.Owners_BrandCountArgs<ExtArgs>
            result: $Utils.Optional<Owners_BrandCountAggregateOutputType> | number
          }
        }
      }
      Roles_Admin: {
        payload: Prisma.$Roles_AdminPayload<ExtArgs>
        fields: Prisma.Roles_AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Roles_AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Roles_AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_AdminPayload>
          }
          findFirst: {
            args: Prisma.Roles_AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Roles_AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_AdminPayload>
          }
          findMany: {
            args: Prisma.Roles_AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_AdminPayload>[]
          }
          create: {
            args: Prisma.Roles_AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_AdminPayload>
          }
          createMany: {
            args: Prisma.Roles_AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Roles_AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_AdminPayload>
          }
          update: {
            args: Prisma.Roles_AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_AdminPayload>
          }
          deleteMany: {
            args: Prisma.Roles_AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Roles_AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Roles_AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_AdminPayload>
          }
          aggregate: {
            args: Prisma.Roles_AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles_Admin>
          }
          groupBy: {
            args: Prisma.Roles_AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<Roles_AdminGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.Roles_AdminFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.Roles_AdminAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.Roles_AdminCountArgs<ExtArgs>
            result: $Utils.Optional<Roles_AdminCountAggregateOutputType> | number
          }
        }
      }
      Roles_KhachHang: {
        payload: Prisma.$Roles_KhachHangPayload<ExtArgs>
        fields: Prisma.Roles_KhachHangFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Roles_KhachHangFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_KhachHangPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Roles_KhachHangFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_KhachHangPayload>
          }
          findFirst: {
            args: Prisma.Roles_KhachHangFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_KhachHangPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Roles_KhachHangFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_KhachHangPayload>
          }
          findMany: {
            args: Prisma.Roles_KhachHangFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_KhachHangPayload>[]
          }
          create: {
            args: Prisma.Roles_KhachHangCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_KhachHangPayload>
          }
          createMany: {
            args: Prisma.Roles_KhachHangCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Roles_KhachHangDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_KhachHangPayload>
          }
          update: {
            args: Prisma.Roles_KhachHangUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_KhachHangPayload>
          }
          deleteMany: {
            args: Prisma.Roles_KhachHangDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Roles_KhachHangUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Roles_KhachHangUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_KhachHangPayload>
          }
          aggregate: {
            args: Prisma.Roles_KhachHangAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles_KhachHang>
          }
          groupBy: {
            args: Prisma.Roles_KhachHangGroupByArgs<ExtArgs>
            result: $Utils.Optional<Roles_KhachHangGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.Roles_KhachHangFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.Roles_KhachHangAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.Roles_KhachHangCountArgs<ExtArgs>
            result: $Utils.Optional<Roles_KhachHangCountAggregateOutputType> | number
          }
        }
      }
      Roles_Staff: {
        payload: Prisma.$Roles_StaffPayload<ExtArgs>
        fields: Prisma.Roles_StaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Roles_StaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_StaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Roles_StaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_StaffPayload>
          }
          findFirst: {
            args: Prisma.Roles_StaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_StaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Roles_StaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_StaffPayload>
          }
          findMany: {
            args: Prisma.Roles_StaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_StaffPayload>[]
          }
          create: {
            args: Prisma.Roles_StaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_StaffPayload>
          }
          createMany: {
            args: Prisma.Roles_StaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Roles_StaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_StaffPayload>
          }
          update: {
            args: Prisma.Roles_StaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_StaffPayload>
          }
          deleteMany: {
            args: Prisma.Roles_StaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Roles_StaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Roles_StaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Roles_StaffPayload>
          }
          aggregate: {
            args: Prisma.Roles_StaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles_Staff>
          }
          groupBy: {
            args: Prisma.Roles_StaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<Roles_StaffGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.Roles_StaffFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.Roles_StaffAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.Roles_StaffCountArgs<ExtArgs>
            result: $Utils.Optional<Roles_StaffCountAggregateOutputType> | number
          }
        }
      }
      Users_Admin: {
        payload: Prisma.$Users_AdminPayload<ExtArgs>
        fields: Prisma.Users_AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Users_AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Users_AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_AdminPayload>
          }
          findFirst: {
            args: Prisma.Users_AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Users_AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_AdminPayload>
          }
          findMany: {
            args: Prisma.Users_AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_AdminPayload>[]
          }
          create: {
            args: Prisma.Users_AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_AdminPayload>
          }
          createMany: {
            args: Prisma.Users_AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Users_AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_AdminPayload>
          }
          update: {
            args: Prisma.Users_AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_AdminPayload>
          }
          deleteMany: {
            args: Prisma.Users_AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Users_AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Users_AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_AdminPayload>
          }
          aggregate: {
            args: Prisma.Users_AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers_Admin>
          }
          groupBy: {
            args: Prisma.Users_AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<Users_AdminGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.Users_AdminFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.Users_AdminAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.Users_AdminCountArgs<ExtArgs>
            result: $Utils.Optional<Users_AdminCountAggregateOutputType> | number
          }
        }
      }
      Users_KhachHang: {
        payload: Prisma.$Users_KhachHangPayload<ExtArgs>
        fields: Prisma.Users_KhachHangFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Users_KhachHangFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_KhachHangPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Users_KhachHangFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_KhachHangPayload>
          }
          findFirst: {
            args: Prisma.Users_KhachHangFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_KhachHangPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Users_KhachHangFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_KhachHangPayload>
          }
          findMany: {
            args: Prisma.Users_KhachHangFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_KhachHangPayload>[]
          }
          create: {
            args: Prisma.Users_KhachHangCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_KhachHangPayload>
          }
          createMany: {
            args: Prisma.Users_KhachHangCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Users_KhachHangDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_KhachHangPayload>
          }
          update: {
            args: Prisma.Users_KhachHangUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_KhachHangPayload>
          }
          deleteMany: {
            args: Prisma.Users_KhachHangDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Users_KhachHangUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Users_KhachHangUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_KhachHangPayload>
          }
          aggregate: {
            args: Prisma.Users_KhachHangAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers_KhachHang>
          }
          groupBy: {
            args: Prisma.Users_KhachHangGroupByArgs<ExtArgs>
            result: $Utils.Optional<Users_KhachHangGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.Users_KhachHangFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.Users_KhachHangAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.Users_KhachHangCountArgs<ExtArgs>
            result: $Utils.Optional<Users_KhachHangCountAggregateOutputType> | number
          }
        }
      }
      Users_Staff: {
        payload: Prisma.$Users_StaffPayload<ExtArgs>
        fields: Prisma.Users_StaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Users_StaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_StaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Users_StaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_StaffPayload>
          }
          findFirst: {
            args: Prisma.Users_StaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_StaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Users_StaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_StaffPayload>
          }
          findMany: {
            args: Prisma.Users_StaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_StaffPayload>[]
          }
          create: {
            args: Prisma.Users_StaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_StaffPayload>
          }
          createMany: {
            args: Prisma.Users_StaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Users_StaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_StaffPayload>
          }
          update: {
            args: Prisma.Users_StaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_StaffPayload>
          }
          deleteMany: {
            args: Prisma.Users_StaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Users_StaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Users_StaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Users_StaffPayload>
          }
          aggregate: {
            args: Prisma.Users_StaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers_Staff>
          }
          groupBy: {
            args: Prisma.Users_StaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<Users_StaffGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.Users_StaffFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.Users_StaffAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.Users_StaffCountArgs<ExtArgs>
            result: $Utils.Optional<Users_StaffCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BrandsCountOutputType
   */

  export type BrandsCountOutputType = {
    owners_brand: number
  }

  export type BrandsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owners_brand?: boolean | BrandsCountOutputTypeCountOwners_brandArgs
  }

  // Custom InputTypes
  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandsCountOutputType
     */
    select?: BrandsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountOwners_brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Owners_BrandWhereInput
  }


  /**
   * Count Type Roles_AdminCountOutputType
   */

  export type Roles_AdminCountOutputType = {
    users_admin: number
  }

  export type Roles_AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_admin?: boolean | Roles_AdminCountOutputTypeCountUsers_adminArgs
  }

  // Custom InputTypes
  /**
   * Roles_AdminCountOutputType without action
   */
  export type Roles_AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_AdminCountOutputType
     */
    select?: Roles_AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Roles_AdminCountOutputType without action
   */
  export type Roles_AdminCountOutputTypeCountUsers_adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Users_AdminWhereInput
  }


  /**
   * Count Type Roles_KhachHangCountOutputType
   */

  export type Roles_KhachHangCountOutputType = {
    users_khachhang: number
  }

  export type Roles_KhachHangCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_khachhang?: boolean | Roles_KhachHangCountOutputTypeCountUsers_khachhangArgs
  }

  // Custom InputTypes
  /**
   * Roles_KhachHangCountOutputType without action
   */
  export type Roles_KhachHangCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_KhachHangCountOutputType
     */
    select?: Roles_KhachHangCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Roles_KhachHangCountOutputType without action
   */
  export type Roles_KhachHangCountOutputTypeCountUsers_khachhangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Users_KhachHangWhereInput
  }


  /**
   * Count Type Roles_StaffCountOutputType
   */

  export type Roles_StaffCountOutputType = {
    users_staff: number
  }

  export type Roles_StaffCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_staff?: boolean | Roles_StaffCountOutputTypeCountUsers_staffArgs
  }

  // Custom InputTypes
  /**
   * Roles_StaffCountOutputType without action
   */
  export type Roles_StaffCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_StaffCountOutputType
     */
    select?: Roles_StaffCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Roles_StaffCountOutputType without action
   */
  export type Roles_StaffCountOutputTypeCountUsers_staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Users_StaffWhereInput
  }


  /**
   * Count Type Users_AdminCountOutputType
   */

  export type Users_AdminCountOutputType = {
    owners_brand: number
  }

  export type Users_AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owners_brand?: boolean | Users_AdminCountOutputTypeCountOwners_brandArgs
  }

  // Custom InputTypes
  /**
   * Users_AdminCountOutputType without action
   */
  export type Users_AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_AdminCountOutputType
     */
    select?: Users_AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Users_AdminCountOutputType without action
   */
  export type Users_AdminCountOutputTypeCountOwners_brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Owners_BrandWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Brands
   */

  export type AggregateBrands = {
    _count: BrandsCountAggregateOutputType | null
    _min: BrandsMinAggregateOutputType | null
    _max: BrandsMaxAggregateOutputType | null
  }

  export type BrandsMinAggregateOutputType = {
    id_brand: string | null
    id_b: string | null
    name: string | null
    description: string | null
    logo: string | null
    status: $Enums.Status_Brand | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandsMaxAggregateOutputType = {
    id_brand: string | null
    id_b: string | null
    name: string | null
    description: string | null
    logo: string | null
    status: $Enums.Status_Brand | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandsCountAggregateOutputType = {
    id_brand: number
    id_b: number
    name: number
    description: number
    logo: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BrandsMinAggregateInputType = {
    id_brand?: true
    id_b?: true
    name?: true
    description?: true
    logo?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandsMaxAggregateInputType = {
    id_brand?: true
    id_b?: true
    name?: true
    description?: true
    logo?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandsCountAggregateInputType = {
    id_brand?: true
    id_b?: true
    name?: true
    description?: true
    logo?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BrandsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brands to aggregate.
     */
    where?: BrandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandsOrderByWithRelationInput | BrandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Brands
    **/
    _count?: true | BrandsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandsMaxAggregateInputType
  }

  export type GetBrandsAggregateType<T extends BrandsAggregateArgs> = {
        [P in keyof T & keyof AggregateBrands]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrands[P]>
      : GetScalarType<T[P], AggregateBrands[P]>
  }




  export type BrandsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrandsWhereInput
    orderBy?: BrandsOrderByWithAggregationInput | BrandsOrderByWithAggregationInput[]
    by: BrandsScalarFieldEnum[] | BrandsScalarFieldEnum
    having?: BrandsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandsCountAggregateInputType | true
    _min?: BrandsMinAggregateInputType
    _max?: BrandsMaxAggregateInputType
  }

  export type BrandsGroupByOutputType = {
    id_brand: string
    id_b: string
    name: string
    description: string | null
    logo: string | null
    status: $Enums.Status_Brand
    createdAt: Date
    updatedAt: Date
    _count: BrandsCountAggregateOutputType | null
    _min: BrandsMinAggregateOutputType | null
    _max: BrandsMaxAggregateOutputType | null
  }

  type GetBrandsGroupByPayload<T extends BrandsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandsGroupByOutputType[P]>
            : GetScalarType<T[P], BrandsGroupByOutputType[P]>
        }
      >
    >


  export type BrandsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_brand?: boolean
    id_b?: boolean
    name?: boolean
    description?: boolean
    logo?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owners_brand?: boolean | Brands$owners_brandArgs<ExtArgs>
    _count?: boolean | BrandsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brands"]>


  export type BrandsSelectScalar = {
    id_brand?: boolean
    id_b?: boolean
    name?: boolean
    description?: boolean
    logo?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BrandsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owners_brand?: boolean | Brands$owners_brandArgs<ExtArgs>
    _count?: boolean | BrandsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BrandsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Brands"
    objects: {
      /**
       * các liên kết bảng khác và dùng để dễ truy vấn
       */
      owners_brand: Prisma.$Owners_BrandPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_brand: string
      id_b: string
      name: string
      description: string | null
      logo: string | null
      status: $Enums.Status_Brand
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["brands"]>
    composites: {}
  }

  type BrandsGetPayload<S extends boolean | null | undefined | BrandsDefaultArgs> = $Result.GetResult<Prisma.$BrandsPayload, S>

  type BrandsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BrandsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BrandsCountAggregateInputType | true
    }

  export interface BrandsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Brands'], meta: { name: 'Brands' } }
    /**
     * Find zero or one Brands that matches the filter.
     * @param {BrandsFindUniqueArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BrandsFindUniqueArgs>(args: SelectSubset<T, BrandsFindUniqueArgs<ExtArgs>>): Prisma__BrandsClient<$Result.GetResult<Prisma.$BrandsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Brands that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BrandsFindUniqueOrThrowArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BrandsFindUniqueOrThrowArgs>(args: SelectSubset<T, BrandsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BrandsClient<$Result.GetResult<Prisma.$BrandsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandsFindFirstArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BrandsFindFirstArgs>(args?: SelectSubset<T, BrandsFindFirstArgs<ExtArgs>>): Prisma__BrandsClient<$Result.GetResult<Prisma.$BrandsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Brands that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandsFindFirstOrThrowArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BrandsFindFirstOrThrowArgs>(args?: SelectSubset<T, BrandsFindFirstOrThrowArgs<ExtArgs>>): Prisma__BrandsClient<$Result.GetResult<Prisma.$BrandsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brands.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brands.findMany({ take: 10 })
     * 
     * // Only select the `id_brand`
     * const brandsWithId_brandOnly = await prisma.brands.findMany({ select: { id_brand: true } })
     * 
     */
    findMany<T extends BrandsFindManyArgs>(args?: SelectSubset<T, BrandsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Brands.
     * @param {BrandsCreateArgs} args - Arguments to create a Brands.
     * @example
     * // Create one Brands
     * const Brands = await prisma.brands.create({
     *   data: {
     *     // ... data to create a Brands
     *   }
     * })
     * 
     */
    create<T extends BrandsCreateArgs>(args: SelectSubset<T, BrandsCreateArgs<ExtArgs>>): Prisma__BrandsClient<$Result.GetResult<Prisma.$BrandsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Brands.
     * @param {BrandsCreateManyArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brands = await prisma.brands.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BrandsCreateManyArgs>(args?: SelectSubset<T, BrandsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Brands.
     * @param {BrandsDeleteArgs} args - Arguments to delete one Brands.
     * @example
     * // Delete one Brands
     * const Brands = await prisma.brands.delete({
     *   where: {
     *     // ... filter to delete one Brands
     *   }
     * })
     * 
     */
    delete<T extends BrandsDeleteArgs>(args: SelectSubset<T, BrandsDeleteArgs<ExtArgs>>): Prisma__BrandsClient<$Result.GetResult<Prisma.$BrandsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Brands.
     * @param {BrandsUpdateArgs} args - Arguments to update one Brands.
     * @example
     * // Update one Brands
     * const brands = await prisma.brands.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BrandsUpdateArgs>(args: SelectSubset<T, BrandsUpdateArgs<ExtArgs>>): Prisma__BrandsClient<$Result.GetResult<Prisma.$BrandsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Brands.
     * @param {BrandsDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brands.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BrandsDeleteManyArgs>(args?: SelectSubset<T, BrandsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brands = await prisma.brands.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BrandsUpdateManyArgs>(args: SelectSubset<T, BrandsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Brands.
     * @param {BrandsUpsertArgs} args - Arguments to update or create a Brands.
     * @example
     * // Update or create a Brands
     * const brands = await prisma.brands.upsert({
     *   create: {
     *     // ... data to create a Brands
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brands we want to update
     *   }
     * })
     */
    upsert<T extends BrandsUpsertArgs>(args: SelectSubset<T, BrandsUpsertArgs<ExtArgs>>): Prisma__BrandsClient<$Result.GetResult<Prisma.$BrandsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Brands that matches the filter.
     * @param {BrandsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const brands = await prisma.brands.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: BrandsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Brands.
     * @param {BrandsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const brands = await prisma.brands.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BrandsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandsCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brands.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends BrandsCountArgs>(
      args?: Subset<T, BrandsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandsAggregateArgs>(args: Subset<T, BrandsAggregateArgs>): Prisma.PrismaPromise<GetBrandsAggregateType<T>>

    /**
     * Group by Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrandsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrandsGroupByArgs['orderBy'] }
        : { orderBy?: BrandsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrandsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Brands model
   */
  readonly fields: BrandsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Brands.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrandsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owners_brand<T extends Brands$owners_brandArgs<ExtArgs> = {}>(args?: Subset<T, Brands$owners_brandArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Owners_BrandPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Brands model
   */ 
  interface BrandsFieldRefs {
    readonly id_brand: FieldRef<"Brands", 'String'>
    readonly id_b: FieldRef<"Brands", 'String'>
    readonly name: FieldRef<"Brands", 'String'>
    readonly description: FieldRef<"Brands", 'String'>
    readonly logo: FieldRef<"Brands", 'String'>
    readonly status: FieldRef<"Brands", 'Status_Brand'>
    readonly createdAt: FieldRef<"Brands", 'DateTime'>
    readonly updatedAt: FieldRef<"Brands", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Brands findUnique
   */
  export type BrandsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brands
     */
    select?: BrandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandsInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where: BrandsWhereUniqueInput
  }

  /**
   * Brands findUniqueOrThrow
   */
  export type BrandsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brands
     */
    select?: BrandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandsInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where: BrandsWhereUniqueInput
  }

  /**
   * Brands findFirst
   */
  export type BrandsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brands
     */
    select?: BrandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandsInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where?: BrandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandsOrderByWithRelationInput | BrandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * Brands findFirstOrThrow
   */
  export type BrandsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brands
     */
    select?: BrandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandsInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where?: BrandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandsOrderByWithRelationInput | BrandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * Brands findMany
   */
  export type BrandsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brands
     */
    select?: BrandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandsInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where?: BrandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandsOrderByWithRelationInput | BrandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Brands.
     */
    cursor?: BrandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * Brands create
   */
  export type BrandsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brands
     */
    select?: BrandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandsInclude<ExtArgs> | null
    /**
     * The data needed to create a Brands.
     */
    data: XOR<BrandsCreateInput, BrandsUncheckedCreateInput>
  }

  /**
   * Brands createMany
   */
  export type BrandsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Brands.
     */
    data: BrandsCreateManyInput | BrandsCreateManyInput[]
  }

  /**
   * Brands update
   */
  export type BrandsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brands
     */
    select?: BrandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandsInclude<ExtArgs> | null
    /**
     * The data needed to update a Brands.
     */
    data: XOR<BrandsUpdateInput, BrandsUncheckedUpdateInput>
    /**
     * Choose, which Brands to update.
     */
    where: BrandsWhereUniqueInput
  }

  /**
   * Brands updateMany
   */
  export type BrandsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandsUpdateManyMutationInput, BrandsUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandsWhereInput
  }

  /**
   * Brands upsert
   */
  export type BrandsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brands
     */
    select?: BrandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandsInclude<ExtArgs> | null
    /**
     * The filter to search for the Brands to update in case it exists.
     */
    where: BrandsWhereUniqueInput
    /**
     * In case the Brands found by the `where` argument doesn't exist, create a new Brands with this data.
     */
    create: XOR<BrandsCreateInput, BrandsUncheckedCreateInput>
    /**
     * In case the Brands was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrandsUpdateInput, BrandsUncheckedUpdateInput>
  }

  /**
   * Brands delete
   */
  export type BrandsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brands
     */
    select?: BrandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandsInclude<ExtArgs> | null
    /**
     * Filter which Brands to delete.
     */
    where: BrandsWhereUniqueInput
  }

  /**
   * Brands deleteMany
   */
  export type BrandsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brands to delete
     */
    where?: BrandsWhereInput
  }

  /**
   * Brands findRaw
   */
  export type BrandsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Brands aggregateRaw
   */
  export type BrandsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Brands.owners_brand
   */
  export type Brands$owners_brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owners_Brand
     */
    select?: Owners_BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Owners_BrandInclude<ExtArgs> | null
    where?: Owners_BrandWhereInput
    orderBy?: Owners_BrandOrderByWithRelationInput | Owners_BrandOrderByWithRelationInput[]
    cursor?: Owners_BrandWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Owners_BrandScalarFieldEnum | Owners_BrandScalarFieldEnum[]
  }

  /**
   * Brands without action
   */
  export type BrandsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brands
     */
    select?: BrandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandsInclude<ExtArgs> | null
  }


  /**
   * Model Owners_Brand
   */

  export type AggregateOwners_Brand = {
    _count: Owners_BrandCountAggregateOutputType | null
    _min: Owners_BrandMinAggregateOutputType | null
    _max: Owners_BrandMaxAggregateOutputType | null
  }

  export type Owners_BrandMinAggregateOutputType = {
    id_owners_brand: string | null
    id_brand: string | null
    id_user_admin: string | null
    createdAt: Date | null
  }

  export type Owners_BrandMaxAggregateOutputType = {
    id_owners_brand: string | null
    id_brand: string | null
    id_user_admin: string | null
    createdAt: Date | null
  }

  export type Owners_BrandCountAggregateOutputType = {
    id_owners_brand: number
    id_brand: number
    id_user_admin: number
    createdAt: number
    _all: number
  }


  export type Owners_BrandMinAggregateInputType = {
    id_owners_brand?: true
    id_brand?: true
    id_user_admin?: true
    createdAt?: true
  }

  export type Owners_BrandMaxAggregateInputType = {
    id_owners_brand?: true
    id_brand?: true
    id_user_admin?: true
    createdAt?: true
  }

  export type Owners_BrandCountAggregateInputType = {
    id_owners_brand?: true
    id_brand?: true
    id_user_admin?: true
    createdAt?: true
    _all?: true
  }

  export type Owners_BrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Owners_Brand to aggregate.
     */
    where?: Owners_BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners_Brands to fetch.
     */
    orderBy?: Owners_BrandOrderByWithRelationInput | Owners_BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Owners_BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners_Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners_Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Owners_Brands
    **/
    _count?: true | Owners_BrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Owners_BrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Owners_BrandMaxAggregateInputType
  }

  export type GetOwners_BrandAggregateType<T extends Owners_BrandAggregateArgs> = {
        [P in keyof T & keyof AggregateOwners_Brand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwners_Brand[P]>
      : GetScalarType<T[P], AggregateOwners_Brand[P]>
  }




  export type Owners_BrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Owners_BrandWhereInput
    orderBy?: Owners_BrandOrderByWithAggregationInput | Owners_BrandOrderByWithAggregationInput[]
    by: Owners_BrandScalarFieldEnum[] | Owners_BrandScalarFieldEnum
    having?: Owners_BrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Owners_BrandCountAggregateInputType | true
    _min?: Owners_BrandMinAggregateInputType
    _max?: Owners_BrandMaxAggregateInputType
  }

  export type Owners_BrandGroupByOutputType = {
    id_owners_brand: string
    id_brand: string
    id_user_admin: string
    createdAt: Date
    _count: Owners_BrandCountAggregateOutputType | null
    _min: Owners_BrandMinAggregateOutputType | null
    _max: Owners_BrandMaxAggregateOutputType | null
  }

  type GetOwners_BrandGroupByPayload<T extends Owners_BrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Owners_BrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Owners_BrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Owners_BrandGroupByOutputType[P]>
            : GetScalarType<T[P], Owners_BrandGroupByOutputType[P]>
        }
      >
    >


  export type Owners_BrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_owners_brand?: boolean
    id_brand?: boolean
    id_user_admin?: boolean
    createdAt?: boolean
    user_admin?: boolean | Users_AdminDefaultArgs<ExtArgs>
    brand?: boolean | BrandsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["owners_Brand"]>


  export type Owners_BrandSelectScalar = {
    id_owners_brand?: boolean
    id_brand?: boolean
    id_user_admin?: boolean
    createdAt?: boolean
  }

  export type Owners_BrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_admin?: boolean | Users_AdminDefaultArgs<ExtArgs>
    brand?: boolean | BrandsDefaultArgs<ExtArgs>
  }

  export type $Owners_BrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Owners_Brand"
    objects: {
      user_admin: Prisma.$Users_AdminPayload<ExtArgs>
      brand: Prisma.$BrandsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_owners_brand: string
      id_brand: string
      id_user_admin: string
      createdAt: Date
    }, ExtArgs["result"]["owners_Brand"]>
    composites: {}
  }

  type Owners_BrandGetPayload<S extends boolean | null | undefined | Owners_BrandDefaultArgs> = $Result.GetResult<Prisma.$Owners_BrandPayload, S>

  type Owners_BrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Owners_BrandFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Owners_BrandCountAggregateInputType | true
    }

  export interface Owners_BrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Owners_Brand'], meta: { name: 'Owners_Brand' } }
    /**
     * Find zero or one Owners_Brand that matches the filter.
     * @param {Owners_BrandFindUniqueArgs} args - Arguments to find a Owners_Brand
     * @example
     * // Get one Owners_Brand
     * const owners_Brand = await prisma.owners_Brand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Owners_BrandFindUniqueArgs>(args: SelectSubset<T, Owners_BrandFindUniqueArgs<ExtArgs>>): Prisma__Owners_BrandClient<$Result.GetResult<Prisma.$Owners_BrandPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Owners_Brand that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Owners_BrandFindUniqueOrThrowArgs} args - Arguments to find a Owners_Brand
     * @example
     * // Get one Owners_Brand
     * const owners_Brand = await prisma.owners_Brand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Owners_BrandFindUniqueOrThrowArgs>(args: SelectSubset<T, Owners_BrandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Owners_BrandClient<$Result.GetResult<Prisma.$Owners_BrandPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Owners_Brand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Owners_BrandFindFirstArgs} args - Arguments to find a Owners_Brand
     * @example
     * // Get one Owners_Brand
     * const owners_Brand = await prisma.owners_Brand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Owners_BrandFindFirstArgs>(args?: SelectSubset<T, Owners_BrandFindFirstArgs<ExtArgs>>): Prisma__Owners_BrandClient<$Result.GetResult<Prisma.$Owners_BrandPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Owners_Brand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Owners_BrandFindFirstOrThrowArgs} args - Arguments to find a Owners_Brand
     * @example
     * // Get one Owners_Brand
     * const owners_Brand = await prisma.owners_Brand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Owners_BrandFindFirstOrThrowArgs>(args?: SelectSubset<T, Owners_BrandFindFirstOrThrowArgs<ExtArgs>>): Prisma__Owners_BrandClient<$Result.GetResult<Prisma.$Owners_BrandPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Owners_Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Owners_BrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Owners_Brands
     * const owners_Brands = await prisma.owners_Brand.findMany()
     * 
     * // Get first 10 Owners_Brands
     * const owners_Brands = await prisma.owners_Brand.findMany({ take: 10 })
     * 
     * // Only select the `id_owners_brand`
     * const owners_BrandWithId_owners_brandOnly = await prisma.owners_Brand.findMany({ select: { id_owners_brand: true } })
     * 
     */
    findMany<T extends Owners_BrandFindManyArgs>(args?: SelectSubset<T, Owners_BrandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Owners_BrandPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Owners_Brand.
     * @param {Owners_BrandCreateArgs} args - Arguments to create a Owners_Brand.
     * @example
     * // Create one Owners_Brand
     * const Owners_Brand = await prisma.owners_Brand.create({
     *   data: {
     *     // ... data to create a Owners_Brand
     *   }
     * })
     * 
     */
    create<T extends Owners_BrandCreateArgs>(args: SelectSubset<T, Owners_BrandCreateArgs<ExtArgs>>): Prisma__Owners_BrandClient<$Result.GetResult<Prisma.$Owners_BrandPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Owners_Brands.
     * @param {Owners_BrandCreateManyArgs} args - Arguments to create many Owners_Brands.
     * @example
     * // Create many Owners_Brands
     * const owners_Brand = await prisma.owners_Brand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Owners_BrandCreateManyArgs>(args?: SelectSubset<T, Owners_BrandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Owners_Brand.
     * @param {Owners_BrandDeleteArgs} args - Arguments to delete one Owners_Brand.
     * @example
     * // Delete one Owners_Brand
     * const Owners_Brand = await prisma.owners_Brand.delete({
     *   where: {
     *     // ... filter to delete one Owners_Brand
     *   }
     * })
     * 
     */
    delete<T extends Owners_BrandDeleteArgs>(args: SelectSubset<T, Owners_BrandDeleteArgs<ExtArgs>>): Prisma__Owners_BrandClient<$Result.GetResult<Prisma.$Owners_BrandPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Owners_Brand.
     * @param {Owners_BrandUpdateArgs} args - Arguments to update one Owners_Brand.
     * @example
     * // Update one Owners_Brand
     * const owners_Brand = await prisma.owners_Brand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Owners_BrandUpdateArgs>(args: SelectSubset<T, Owners_BrandUpdateArgs<ExtArgs>>): Prisma__Owners_BrandClient<$Result.GetResult<Prisma.$Owners_BrandPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Owners_Brands.
     * @param {Owners_BrandDeleteManyArgs} args - Arguments to filter Owners_Brands to delete.
     * @example
     * // Delete a few Owners_Brands
     * const { count } = await prisma.owners_Brand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Owners_BrandDeleteManyArgs>(args?: SelectSubset<T, Owners_BrandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Owners_Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Owners_BrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Owners_Brands
     * const owners_Brand = await prisma.owners_Brand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Owners_BrandUpdateManyArgs>(args: SelectSubset<T, Owners_BrandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Owners_Brand.
     * @param {Owners_BrandUpsertArgs} args - Arguments to update or create a Owners_Brand.
     * @example
     * // Update or create a Owners_Brand
     * const owners_Brand = await prisma.owners_Brand.upsert({
     *   create: {
     *     // ... data to create a Owners_Brand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Owners_Brand we want to update
     *   }
     * })
     */
    upsert<T extends Owners_BrandUpsertArgs>(args: SelectSubset<T, Owners_BrandUpsertArgs<ExtArgs>>): Prisma__Owners_BrandClient<$Result.GetResult<Prisma.$Owners_BrandPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Owners_Brands that matches the filter.
     * @param {Owners_BrandFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const owners_Brand = await prisma.owners_Brand.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: Owners_BrandFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Owners_Brand.
     * @param {Owners_BrandAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const owners_Brand = await prisma.owners_Brand.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: Owners_BrandAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Owners_Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Owners_BrandCountArgs} args - Arguments to filter Owners_Brands to count.
     * @example
     * // Count the number of Owners_Brands
     * const count = await prisma.owners_Brand.count({
     *   where: {
     *     // ... the filter for the Owners_Brands we want to count
     *   }
     * })
    **/
    count<T extends Owners_BrandCountArgs>(
      args?: Subset<T, Owners_BrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Owners_BrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Owners_Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Owners_BrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Owners_BrandAggregateArgs>(args: Subset<T, Owners_BrandAggregateArgs>): Prisma.PrismaPromise<GetOwners_BrandAggregateType<T>>

    /**
     * Group by Owners_Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Owners_BrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Owners_BrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Owners_BrandGroupByArgs['orderBy'] }
        : { orderBy?: Owners_BrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Owners_BrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOwners_BrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Owners_Brand model
   */
  readonly fields: Owners_BrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Owners_Brand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Owners_BrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_admin<T extends Users_AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Users_AdminDefaultArgs<ExtArgs>>): Prisma__Users_AdminClient<$Result.GetResult<Prisma.$Users_AdminPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    brand<T extends BrandsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BrandsDefaultArgs<ExtArgs>>): Prisma__BrandsClient<$Result.GetResult<Prisma.$BrandsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Owners_Brand model
   */ 
  interface Owners_BrandFieldRefs {
    readonly id_owners_brand: FieldRef<"Owners_Brand", 'String'>
    readonly id_brand: FieldRef<"Owners_Brand", 'String'>
    readonly id_user_admin: FieldRef<"Owners_Brand", 'String'>
    readonly createdAt: FieldRef<"Owners_Brand", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Owners_Brand findUnique
   */
  export type Owners_BrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owners_Brand
     */
    select?: Owners_BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Owners_BrandInclude<ExtArgs> | null
    /**
     * Filter, which Owners_Brand to fetch.
     */
    where: Owners_BrandWhereUniqueInput
  }

  /**
   * Owners_Brand findUniqueOrThrow
   */
  export type Owners_BrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owners_Brand
     */
    select?: Owners_BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Owners_BrandInclude<ExtArgs> | null
    /**
     * Filter, which Owners_Brand to fetch.
     */
    where: Owners_BrandWhereUniqueInput
  }

  /**
   * Owners_Brand findFirst
   */
  export type Owners_BrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owners_Brand
     */
    select?: Owners_BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Owners_BrandInclude<ExtArgs> | null
    /**
     * Filter, which Owners_Brand to fetch.
     */
    where?: Owners_BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners_Brands to fetch.
     */
    orderBy?: Owners_BrandOrderByWithRelationInput | Owners_BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Owners_Brands.
     */
    cursor?: Owners_BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners_Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners_Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Owners_Brands.
     */
    distinct?: Owners_BrandScalarFieldEnum | Owners_BrandScalarFieldEnum[]
  }

  /**
   * Owners_Brand findFirstOrThrow
   */
  export type Owners_BrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owners_Brand
     */
    select?: Owners_BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Owners_BrandInclude<ExtArgs> | null
    /**
     * Filter, which Owners_Brand to fetch.
     */
    where?: Owners_BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners_Brands to fetch.
     */
    orderBy?: Owners_BrandOrderByWithRelationInput | Owners_BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Owners_Brands.
     */
    cursor?: Owners_BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners_Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners_Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Owners_Brands.
     */
    distinct?: Owners_BrandScalarFieldEnum | Owners_BrandScalarFieldEnum[]
  }

  /**
   * Owners_Brand findMany
   */
  export type Owners_BrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owners_Brand
     */
    select?: Owners_BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Owners_BrandInclude<ExtArgs> | null
    /**
     * Filter, which Owners_Brands to fetch.
     */
    where?: Owners_BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners_Brands to fetch.
     */
    orderBy?: Owners_BrandOrderByWithRelationInput | Owners_BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Owners_Brands.
     */
    cursor?: Owners_BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners_Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners_Brands.
     */
    skip?: number
    distinct?: Owners_BrandScalarFieldEnum | Owners_BrandScalarFieldEnum[]
  }

  /**
   * Owners_Brand create
   */
  export type Owners_BrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owners_Brand
     */
    select?: Owners_BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Owners_BrandInclude<ExtArgs> | null
    /**
     * The data needed to create a Owners_Brand.
     */
    data: XOR<Owners_BrandCreateInput, Owners_BrandUncheckedCreateInput>
  }

  /**
   * Owners_Brand createMany
   */
  export type Owners_BrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Owners_Brands.
     */
    data: Owners_BrandCreateManyInput | Owners_BrandCreateManyInput[]
  }

  /**
   * Owners_Brand update
   */
  export type Owners_BrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owners_Brand
     */
    select?: Owners_BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Owners_BrandInclude<ExtArgs> | null
    /**
     * The data needed to update a Owners_Brand.
     */
    data: XOR<Owners_BrandUpdateInput, Owners_BrandUncheckedUpdateInput>
    /**
     * Choose, which Owners_Brand to update.
     */
    where: Owners_BrandWhereUniqueInput
  }

  /**
   * Owners_Brand updateMany
   */
  export type Owners_BrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Owners_Brands.
     */
    data: XOR<Owners_BrandUpdateManyMutationInput, Owners_BrandUncheckedUpdateManyInput>
    /**
     * Filter which Owners_Brands to update
     */
    where?: Owners_BrandWhereInput
  }

  /**
   * Owners_Brand upsert
   */
  export type Owners_BrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owners_Brand
     */
    select?: Owners_BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Owners_BrandInclude<ExtArgs> | null
    /**
     * The filter to search for the Owners_Brand to update in case it exists.
     */
    where: Owners_BrandWhereUniqueInput
    /**
     * In case the Owners_Brand found by the `where` argument doesn't exist, create a new Owners_Brand with this data.
     */
    create: XOR<Owners_BrandCreateInput, Owners_BrandUncheckedCreateInput>
    /**
     * In case the Owners_Brand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Owners_BrandUpdateInput, Owners_BrandUncheckedUpdateInput>
  }

  /**
   * Owners_Brand delete
   */
  export type Owners_BrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owners_Brand
     */
    select?: Owners_BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Owners_BrandInclude<ExtArgs> | null
    /**
     * Filter which Owners_Brand to delete.
     */
    where: Owners_BrandWhereUniqueInput
  }

  /**
   * Owners_Brand deleteMany
   */
  export type Owners_BrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Owners_Brands to delete
     */
    where?: Owners_BrandWhereInput
  }

  /**
   * Owners_Brand findRaw
   */
  export type Owners_BrandFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Owners_Brand aggregateRaw
   */
  export type Owners_BrandAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Owners_Brand without action
   */
  export type Owners_BrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owners_Brand
     */
    select?: Owners_BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Owners_BrandInclude<ExtArgs> | null
  }


  /**
   * Model Roles_Admin
   */

  export type AggregateRoles_Admin = {
    _count: Roles_AdminCountAggregateOutputType | null
    _min: Roles_AdminMinAggregateOutputType | null
    _max: Roles_AdminMaxAggregateOutputType | null
  }

  export type Roles_AdminMinAggregateOutputType = {
    id_role_admin: string | null
    id_ra: string | null
    name: string | null
    description: string | null
  }

  export type Roles_AdminMaxAggregateOutputType = {
    id_role_admin: string | null
    id_ra: string | null
    name: string | null
    description: string | null
  }

  export type Roles_AdminCountAggregateOutputType = {
    id_role_admin: number
    id_ra: number
    name: number
    description: number
    _all: number
  }


  export type Roles_AdminMinAggregateInputType = {
    id_role_admin?: true
    id_ra?: true
    name?: true
    description?: true
  }

  export type Roles_AdminMaxAggregateInputType = {
    id_role_admin?: true
    id_ra?: true
    name?: true
    description?: true
  }

  export type Roles_AdminCountAggregateInputType = {
    id_role_admin?: true
    id_ra?: true
    name?: true
    description?: true
    _all?: true
  }

  export type Roles_AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles_Admin to aggregate.
     */
    where?: Roles_AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles_Admins to fetch.
     */
    orderBy?: Roles_AdminOrderByWithRelationInput | Roles_AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Roles_AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles_Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles_Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles_Admins
    **/
    _count?: true | Roles_AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Roles_AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Roles_AdminMaxAggregateInputType
  }

  export type GetRoles_AdminAggregateType<T extends Roles_AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles_Admin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles_Admin[P]>
      : GetScalarType<T[P], AggregateRoles_Admin[P]>
  }




  export type Roles_AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Roles_AdminWhereInput
    orderBy?: Roles_AdminOrderByWithAggregationInput | Roles_AdminOrderByWithAggregationInput[]
    by: Roles_AdminScalarFieldEnum[] | Roles_AdminScalarFieldEnum
    having?: Roles_AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Roles_AdminCountAggregateInputType | true
    _min?: Roles_AdminMinAggregateInputType
    _max?: Roles_AdminMaxAggregateInputType
  }

  export type Roles_AdminGroupByOutputType = {
    id_role_admin: string
    id_ra: string
    name: string
    description: string | null
    _count: Roles_AdminCountAggregateOutputType | null
    _min: Roles_AdminMinAggregateOutputType | null
    _max: Roles_AdminMaxAggregateOutputType | null
  }

  type GetRoles_AdminGroupByPayload<T extends Roles_AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Roles_AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Roles_AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Roles_AdminGroupByOutputType[P]>
            : GetScalarType<T[P], Roles_AdminGroupByOutputType[P]>
        }
      >
    >


  export type Roles_AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_role_admin?: boolean
    id_ra?: boolean
    name?: boolean
    description?: boolean
    users_admin?: boolean | Roles_Admin$users_adminArgs<ExtArgs>
    _count?: boolean | Roles_AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles_Admin"]>


  export type Roles_AdminSelectScalar = {
    id_role_admin?: boolean
    id_ra?: boolean
    name?: boolean
    description?: boolean
  }

  export type Roles_AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_admin?: boolean | Roles_Admin$users_adminArgs<ExtArgs>
    _count?: boolean | Roles_AdminCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $Roles_AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Roles_Admin"
    objects: {
      users_admin: Prisma.$Users_AdminPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_role_admin: string
      id_ra: string
      name: string
      description: string | null
    }, ExtArgs["result"]["roles_Admin"]>
    composites: {}
  }

  type Roles_AdminGetPayload<S extends boolean | null | undefined | Roles_AdminDefaultArgs> = $Result.GetResult<Prisma.$Roles_AdminPayload, S>

  type Roles_AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Roles_AdminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Roles_AdminCountAggregateInputType | true
    }

  export interface Roles_AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roles_Admin'], meta: { name: 'Roles_Admin' } }
    /**
     * Find zero or one Roles_Admin that matches the filter.
     * @param {Roles_AdminFindUniqueArgs} args - Arguments to find a Roles_Admin
     * @example
     * // Get one Roles_Admin
     * const roles_Admin = await prisma.roles_Admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Roles_AdminFindUniqueArgs>(args: SelectSubset<T, Roles_AdminFindUniqueArgs<ExtArgs>>): Prisma__Roles_AdminClient<$Result.GetResult<Prisma.$Roles_AdminPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Roles_Admin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Roles_AdminFindUniqueOrThrowArgs} args - Arguments to find a Roles_Admin
     * @example
     * // Get one Roles_Admin
     * const roles_Admin = await prisma.roles_Admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Roles_AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, Roles_AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Roles_AdminClient<$Result.GetResult<Prisma.$Roles_AdminPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Roles_Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Roles_AdminFindFirstArgs} args - Arguments to find a Roles_Admin
     * @example
     * // Get one Roles_Admin
     * const roles_Admin = await prisma.roles_Admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Roles_AdminFindFirstArgs>(args?: SelectSubset<T, Roles_AdminFindFirstArgs<ExtArgs>>): Prisma__Roles_AdminClient<$Result.GetResult<Prisma.$Roles_AdminPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Roles_Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Roles_AdminFindFirstOrThrowArgs} args - Arguments to find a Roles_Admin
     * @example
     * // Get one Roles_Admin
     * const roles_Admin = await prisma.roles_Admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Roles_AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, Roles_AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__Roles_AdminClient<$Result.GetResult<Prisma.$Roles_AdminPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles_Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Roles_AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles_Admins
     * const roles_Admins = await prisma.roles_Admin.findMany()
     * 
     * // Get first 10 Roles_Admins
     * const roles_Admins = await prisma.roles_Admin.findMany({ take: 10 })
     * 
     * // Only select the `id_role_admin`
     * const roles_AdminWithId_role_adminOnly = await prisma.roles_Admin.findMany({ select: { id_role_admin: true } })
     * 
     */
    findMany<T extends Roles_AdminFindManyArgs>(args?: SelectSubset<T, Roles_AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Roles_AdminPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Roles_Admin.
     * @param {Roles_AdminCreateArgs} args - Arguments to create a Roles_Admin.
     * @example
     * // Create one Roles_Admin
     * const Roles_Admin = await prisma.roles_Admin.create({
     *   data: {
     *     // ... data to create a Roles_Admin
     *   }
     * })
     * 
     */
    create<T extends Roles_AdminCreateArgs>(args: SelectSubset<T, Roles_AdminCreateArgs<ExtArgs>>): Prisma__Roles_AdminClient<$Result.GetResult<Prisma.$Roles_AdminPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles_Admins.
     * @param {Roles_AdminCreateManyArgs} args - Arguments to create many Roles_Admins.
     * @example
     * // Create many Roles_Admins
     * const roles_Admin = await prisma.roles_Admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Roles_AdminCreateManyArgs>(args?: SelectSubset<T, Roles_AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roles_Admin.
     * @param {Roles_AdminDeleteArgs} args - Arguments to delete one Roles_Admin.
     * @example
     * // Delete one Roles_Admin
     * const Roles_Admin = await prisma.roles_Admin.delete({
     *   where: {
     *     // ... filter to delete one Roles_Admin
     *   }
     * })
     * 
     */
    delete<T extends Roles_AdminDeleteArgs>(args: SelectSubset<T, Roles_AdminDeleteArgs<ExtArgs>>): Prisma__Roles_AdminClient<$Result.GetResult<Prisma.$Roles_AdminPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Roles_Admin.
     * @param {Roles_AdminUpdateArgs} args - Arguments to update one Roles_Admin.
     * @example
     * // Update one Roles_Admin
     * const roles_Admin = await prisma.roles_Admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Roles_AdminUpdateArgs>(args: SelectSubset<T, Roles_AdminUpdateArgs<ExtArgs>>): Prisma__Roles_AdminClient<$Result.GetResult<Prisma.$Roles_AdminPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles_Admins.
     * @param {Roles_AdminDeleteManyArgs} args - Arguments to filter Roles_Admins to delete.
     * @example
     * // Delete a few Roles_Admins
     * const { count } = await prisma.roles_Admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Roles_AdminDeleteManyArgs>(args?: SelectSubset<T, Roles_AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles_Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Roles_AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles_Admins
     * const roles_Admin = await prisma.roles_Admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Roles_AdminUpdateManyArgs>(args: SelectSubset<T, Roles_AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles_Admin.
     * @param {Roles_AdminUpsertArgs} args - Arguments to update or create a Roles_Admin.
     * @example
     * // Update or create a Roles_Admin
     * const roles_Admin = await prisma.roles_Admin.upsert({
     *   create: {
     *     // ... data to create a Roles_Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles_Admin we want to update
     *   }
     * })
     */
    upsert<T extends Roles_AdminUpsertArgs>(args: SelectSubset<T, Roles_AdminUpsertArgs<ExtArgs>>): Prisma__Roles_AdminClient<$Result.GetResult<Prisma.$Roles_AdminPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Roles_Admins that matches the filter.
     * @param {Roles_AdminFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const roles_Admin = await prisma.roles_Admin.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: Roles_AdminFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Roles_Admin.
     * @param {Roles_AdminAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const roles_Admin = await prisma.roles_Admin.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: Roles_AdminAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Roles_Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Roles_AdminCountArgs} args - Arguments to filter Roles_Admins to count.
     * @example
     * // Count the number of Roles_Admins
     * const count = await prisma.roles_Admin.count({
     *   where: {
     *     // ... the filter for the Roles_Admins we want to count
     *   }
     * })
    **/
    count<T extends Roles_AdminCountArgs>(
      args?: Subset<T, Roles_AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Roles_AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles_Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Roles_AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Roles_AdminAggregateArgs>(args: Subset<T, Roles_AdminAggregateArgs>): Prisma.PrismaPromise<GetRoles_AdminAggregateType<T>>

    /**
     * Group by Roles_Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Roles_AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Roles_AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Roles_AdminGroupByArgs['orderBy'] }
        : { orderBy?: Roles_AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Roles_AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoles_AdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Roles_Admin model
   */
  readonly fields: Roles_AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roles_Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Roles_AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_admin<T extends Roles_Admin$users_adminArgs<ExtArgs> = {}>(args?: Subset<T, Roles_Admin$users_adminArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Users_AdminPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Roles_Admin model
   */ 
  interface Roles_AdminFieldRefs {
    readonly id_role_admin: FieldRef<"Roles_Admin", 'String'>
    readonly id_ra: FieldRef<"Roles_Admin", 'String'>
    readonly name: FieldRef<"Roles_Admin", 'String'>
    readonly description: FieldRef<"Roles_Admin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Roles_Admin findUnique
   */
  export type Roles_AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_Admin
     */
    select?: Roles_AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_AdminInclude<ExtArgs> | null
    /**
     * Filter, which Roles_Admin to fetch.
     */
    where: Roles_AdminWhereUniqueInput
  }

  /**
   * Roles_Admin findUniqueOrThrow
   */
  export type Roles_AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_Admin
     */
    select?: Roles_AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_AdminInclude<ExtArgs> | null
    /**
     * Filter, which Roles_Admin to fetch.
     */
    where: Roles_AdminWhereUniqueInput
  }

  /**
   * Roles_Admin findFirst
   */
  export type Roles_AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_Admin
     */
    select?: Roles_AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_AdminInclude<ExtArgs> | null
    /**
     * Filter, which Roles_Admin to fetch.
     */
    where?: Roles_AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles_Admins to fetch.
     */
    orderBy?: Roles_AdminOrderByWithRelationInput | Roles_AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles_Admins.
     */
    cursor?: Roles_AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles_Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles_Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles_Admins.
     */
    distinct?: Roles_AdminScalarFieldEnum | Roles_AdminScalarFieldEnum[]
  }

  /**
   * Roles_Admin findFirstOrThrow
   */
  export type Roles_AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_Admin
     */
    select?: Roles_AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_AdminInclude<ExtArgs> | null
    /**
     * Filter, which Roles_Admin to fetch.
     */
    where?: Roles_AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles_Admins to fetch.
     */
    orderBy?: Roles_AdminOrderByWithRelationInput | Roles_AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles_Admins.
     */
    cursor?: Roles_AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles_Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles_Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles_Admins.
     */
    distinct?: Roles_AdminScalarFieldEnum | Roles_AdminScalarFieldEnum[]
  }

  /**
   * Roles_Admin findMany
   */
  export type Roles_AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_Admin
     */
    select?: Roles_AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_AdminInclude<ExtArgs> | null
    /**
     * Filter, which Roles_Admins to fetch.
     */
    where?: Roles_AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles_Admins to fetch.
     */
    orderBy?: Roles_AdminOrderByWithRelationInput | Roles_AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles_Admins.
     */
    cursor?: Roles_AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles_Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles_Admins.
     */
    skip?: number
    distinct?: Roles_AdminScalarFieldEnum | Roles_AdminScalarFieldEnum[]
  }

  /**
   * Roles_Admin create
   */
  export type Roles_AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_Admin
     */
    select?: Roles_AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Roles_Admin.
     */
    data: XOR<Roles_AdminCreateInput, Roles_AdminUncheckedCreateInput>
  }

  /**
   * Roles_Admin createMany
   */
  export type Roles_AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles_Admins.
     */
    data: Roles_AdminCreateManyInput | Roles_AdminCreateManyInput[]
  }

  /**
   * Roles_Admin update
   */
  export type Roles_AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_Admin
     */
    select?: Roles_AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Roles_Admin.
     */
    data: XOR<Roles_AdminUpdateInput, Roles_AdminUncheckedUpdateInput>
    /**
     * Choose, which Roles_Admin to update.
     */
    where: Roles_AdminWhereUniqueInput
  }

  /**
   * Roles_Admin updateMany
   */
  export type Roles_AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles_Admins.
     */
    data: XOR<Roles_AdminUpdateManyMutationInput, Roles_AdminUncheckedUpdateManyInput>
    /**
     * Filter which Roles_Admins to update
     */
    where?: Roles_AdminWhereInput
  }

  /**
   * Roles_Admin upsert
   */
  export type Roles_AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_Admin
     */
    select?: Roles_AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Roles_Admin to update in case it exists.
     */
    where: Roles_AdminWhereUniqueInput
    /**
     * In case the Roles_Admin found by the `where` argument doesn't exist, create a new Roles_Admin with this data.
     */
    create: XOR<Roles_AdminCreateInput, Roles_AdminUncheckedCreateInput>
    /**
     * In case the Roles_Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Roles_AdminUpdateInput, Roles_AdminUncheckedUpdateInput>
  }

  /**
   * Roles_Admin delete
   */
  export type Roles_AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_Admin
     */
    select?: Roles_AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_AdminInclude<ExtArgs> | null
    /**
     * Filter which Roles_Admin to delete.
     */
    where: Roles_AdminWhereUniqueInput
  }

  /**
   * Roles_Admin deleteMany
   */
  export type Roles_AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles_Admins to delete
     */
    where?: Roles_AdminWhereInput
  }

  /**
   * Roles_Admin findRaw
   */
  export type Roles_AdminFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Roles_Admin aggregateRaw
   */
  export type Roles_AdminAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Roles_Admin.users_admin
   */
  export type Roles_Admin$users_adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_Admin
     */
    select?: Users_AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_AdminInclude<ExtArgs> | null
    where?: Users_AdminWhereInput
    orderBy?: Users_AdminOrderByWithRelationInput | Users_AdminOrderByWithRelationInput[]
    cursor?: Users_AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Users_AdminScalarFieldEnum | Users_AdminScalarFieldEnum[]
  }

  /**
   * Roles_Admin without action
   */
  export type Roles_AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_Admin
     */
    select?: Roles_AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_AdminInclude<ExtArgs> | null
  }


  /**
   * Model Roles_KhachHang
   */

  export type AggregateRoles_KhachHang = {
    _count: Roles_KhachHangCountAggregateOutputType | null
    _min: Roles_KhachHangMinAggregateOutputType | null
    _max: Roles_KhachHangMaxAggregateOutputType | null
  }

  export type Roles_KhachHangMinAggregateOutputType = {
    id_role_KhachHang: string | null
    id_rkh: string | null
    name: string | null
    description: string | null
  }

  export type Roles_KhachHangMaxAggregateOutputType = {
    id_role_KhachHang: string | null
    id_rkh: string | null
    name: string | null
    description: string | null
  }

  export type Roles_KhachHangCountAggregateOutputType = {
    id_role_KhachHang: number
    id_rkh: number
    name: number
    description: number
    _all: number
  }


  export type Roles_KhachHangMinAggregateInputType = {
    id_role_KhachHang?: true
    id_rkh?: true
    name?: true
    description?: true
  }

  export type Roles_KhachHangMaxAggregateInputType = {
    id_role_KhachHang?: true
    id_rkh?: true
    name?: true
    description?: true
  }

  export type Roles_KhachHangCountAggregateInputType = {
    id_role_KhachHang?: true
    id_rkh?: true
    name?: true
    description?: true
    _all?: true
  }

  export type Roles_KhachHangAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles_KhachHang to aggregate.
     */
    where?: Roles_KhachHangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles_KhachHangs to fetch.
     */
    orderBy?: Roles_KhachHangOrderByWithRelationInput | Roles_KhachHangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Roles_KhachHangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles_KhachHangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles_KhachHangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles_KhachHangs
    **/
    _count?: true | Roles_KhachHangCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Roles_KhachHangMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Roles_KhachHangMaxAggregateInputType
  }

  export type GetRoles_KhachHangAggregateType<T extends Roles_KhachHangAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles_KhachHang]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles_KhachHang[P]>
      : GetScalarType<T[P], AggregateRoles_KhachHang[P]>
  }




  export type Roles_KhachHangGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Roles_KhachHangWhereInput
    orderBy?: Roles_KhachHangOrderByWithAggregationInput | Roles_KhachHangOrderByWithAggregationInput[]
    by: Roles_KhachHangScalarFieldEnum[] | Roles_KhachHangScalarFieldEnum
    having?: Roles_KhachHangScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Roles_KhachHangCountAggregateInputType | true
    _min?: Roles_KhachHangMinAggregateInputType
    _max?: Roles_KhachHangMaxAggregateInputType
  }

  export type Roles_KhachHangGroupByOutputType = {
    id_role_KhachHang: string
    id_rkh: string
    name: string
    description: string | null
    _count: Roles_KhachHangCountAggregateOutputType | null
    _min: Roles_KhachHangMinAggregateOutputType | null
    _max: Roles_KhachHangMaxAggregateOutputType | null
  }

  type GetRoles_KhachHangGroupByPayload<T extends Roles_KhachHangGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Roles_KhachHangGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Roles_KhachHangGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Roles_KhachHangGroupByOutputType[P]>
            : GetScalarType<T[P], Roles_KhachHangGroupByOutputType[P]>
        }
      >
    >


  export type Roles_KhachHangSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_role_KhachHang?: boolean
    id_rkh?: boolean
    name?: boolean
    description?: boolean
    users_khachhang?: boolean | Roles_KhachHang$users_khachhangArgs<ExtArgs>
    _count?: boolean | Roles_KhachHangCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles_KhachHang"]>


  export type Roles_KhachHangSelectScalar = {
    id_role_KhachHang?: boolean
    id_rkh?: boolean
    name?: boolean
    description?: boolean
  }

  export type Roles_KhachHangInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_khachhang?: boolean | Roles_KhachHang$users_khachhangArgs<ExtArgs>
    _count?: boolean | Roles_KhachHangCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $Roles_KhachHangPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Roles_KhachHang"
    objects: {
      /**
       * các liên kết bảng khác và dùng để dễ truy vấn
       */
      users_khachhang: Prisma.$Users_KhachHangPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_role_KhachHang: string
      id_rkh: string
      name: string
      description: string | null
    }, ExtArgs["result"]["roles_KhachHang"]>
    composites: {}
  }

  type Roles_KhachHangGetPayload<S extends boolean | null | undefined | Roles_KhachHangDefaultArgs> = $Result.GetResult<Prisma.$Roles_KhachHangPayload, S>

  type Roles_KhachHangCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Roles_KhachHangFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Roles_KhachHangCountAggregateInputType | true
    }

  export interface Roles_KhachHangDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roles_KhachHang'], meta: { name: 'Roles_KhachHang' } }
    /**
     * Find zero or one Roles_KhachHang that matches the filter.
     * @param {Roles_KhachHangFindUniqueArgs} args - Arguments to find a Roles_KhachHang
     * @example
     * // Get one Roles_KhachHang
     * const roles_KhachHang = await prisma.roles_KhachHang.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Roles_KhachHangFindUniqueArgs>(args: SelectSubset<T, Roles_KhachHangFindUniqueArgs<ExtArgs>>): Prisma__Roles_KhachHangClient<$Result.GetResult<Prisma.$Roles_KhachHangPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Roles_KhachHang that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Roles_KhachHangFindUniqueOrThrowArgs} args - Arguments to find a Roles_KhachHang
     * @example
     * // Get one Roles_KhachHang
     * const roles_KhachHang = await prisma.roles_KhachHang.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Roles_KhachHangFindUniqueOrThrowArgs>(args: SelectSubset<T, Roles_KhachHangFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Roles_KhachHangClient<$Result.GetResult<Prisma.$Roles_KhachHangPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Roles_KhachHang that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Roles_KhachHangFindFirstArgs} args - Arguments to find a Roles_KhachHang
     * @example
     * // Get one Roles_KhachHang
     * const roles_KhachHang = await prisma.roles_KhachHang.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Roles_KhachHangFindFirstArgs>(args?: SelectSubset<T, Roles_KhachHangFindFirstArgs<ExtArgs>>): Prisma__Roles_KhachHangClient<$Result.GetResult<Prisma.$Roles_KhachHangPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Roles_KhachHang that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Roles_KhachHangFindFirstOrThrowArgs} args - Arguments to find a Roles_KhachHang
     * @example
     * // Get one Roles_KhachHang
     * const roles_KhachHang = await prisma.roles_KhachHang.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Roles_KhachHangFindFirstOrThrowArgs>(args?: SelectSubset<T, Roles_KhachHangFindFirstOrThrowArgs<ExtArgs>>): Prisma__Roles_KhachHangClient<$Result.GetResult<Prisma.$Roles_KhachHangPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles_KhachHangs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Roles_KhachHangFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles_KhachHangs
     * const roles_KhachHangs = await prisma.roles_KhachHang.findMany()
     * 
     * // Get first 10 Roles_KhachHangs
     * const roles_KhachHangs = await prisma.roles_KhachHang.findMany({ take: 10 })
     * 
     * // Only select the `id_role_KhachHang`
     * const roles_KhachHangWithId_role_KhachHangOnly = await prisma.roles_KhachHang.findMany({ select: { id_role_KhachHang: true } })
     * 
     */
    findMany<T extends Roles_KhachHangFindManyArgs>(args?: SelectSubset<T, Roles_KhachHangFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Roles_KhachHangPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Roles_KhachHang.
     * @param {Roles_KhachHangCreateArgs} args - Arguments to create a Roles_KhachHang.
     * @example
     * // Create one Roles_KhachHang
     * const Roles_KhachHang = await prisma.roles_KhachHang.create({
     *   data: {
     *     // ... data to create a Roles_KhachHang
     *   }
     * })
     * 
     */
    create<T extends Roles_KhachHangCreateArgs>(args: SelectSubset<T, Roles_KhachHangCreateArgs<ExtArgs>>): Prisma__Roles_KhachHangClient<$Result.GetResult<Prisma.$Roles_KhachHangPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles_KhachHangs.
     * @param {Roles_KhachHangCreateManyArgs} args - Arguments to create many Roles_KhachHangs.
     * @example
     * // Create many Roles_KhachHangs
     * const roles_KhachHang = await prisma.roles_KhachHang.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Roles_KhachHangCreateManyArgs>(args?: SelectSubset<T, Roles_KhachHangCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roles_KhachHang.
     * @param {Roles_KhachHangDeleteArgs} args - Arguments to delete one Roles_KhachHang.
     * @example
     * // Delete one Roles_KhachHang
     * const Roles_KhachHang = await prisma.roles_KhachHang.delete({
     *   where: {
     *     // ... filter to delete one Roles_KhachHang
     *   }
     * })
     * 
     */
    delete<T extends Roles_KhachHangDeleteArgs>(args: SelectSubset<T, Roles_KhachHangDeleteArgs<ExtArgs>>): Prisma__Roles_KhachHangClient<$Result.GetResult<Prisma.$Roles_KhachHangPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Roles_KhachHang.
     * @param {Roles_KhachHangUpdateArgs} args - Arguments to update one Roles_KhachHang.
     * @example
     * // Update one Roles_KhachHang
     * const roles_KhachHang = await prisma.roles_KhachHang.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Roles_KhachHangUpdateArgs>(args: SelectSubset<T, Roles_KhachHangUpdateArgs<ExtArgs>>): Prisma__Roles_KhachHangClient<$Result.GetResult<Prisma.$Roles_KhachHangPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles_KhachHangs.
     * @param {Roles_KhachHangDeleteManyArgs} args - Arguments to filter Roles_KhachHangs to delete.
     * @example
     * // Delete a few Roles_KhachHangs
     * const { count } = await prisma.roles_KhachHang.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Roles_KhachHangDeleteManyArgs>(args?: SelectSubset<T, Roles_KhachHangDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles_KhachHangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Roles_KhachHangUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles_KhachHangs
     * const roles_KhachHang = await prisma.roles_KhachHang.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Roles_KhachHangUpdateManyArgs>(args: SelectSubset<T, Roles_KhachHangUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles_KhachHang.
     * @param {Roles_KhachHangUpsertArgs} args - Arguments to update or create a Roles_KhachHang.
     * @example
     * // Update or create a Roles_KhachHang
     * const roles_KhachHang = await prisma.roles_KhachHang.upsert({
     *   create: {
     *     // ... data to create a Roles_KhachHang
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles_KhachHang we want to update
     *   }
     * })
     */
    upsert<T extends Roles_KhachHangUpsertArgs>(args: SelectSubset<T, Roles_KhachHangUpsertArgs<ExtArgs>>): Prisma__Roles_KhachHangClient<$Result.GetResult<Prisma.$Roles_KhachHangPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Roles_KhachHangs that matches the filter.
     * @param {Roles_KhachHangFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const roles_KhachHang = await prisma.roles_KhachHang.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: Roles_KhachHangFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Roles_KhachHang.
     * @param {Roles_KhachHangAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const roles_KhachHang = await prisma.roles_KhachHang.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: Roles_KhachHangAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Roles_KhachHangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Roles_KhachHangCountArgs} args - Arguments to filter Roles_KhachHangs to count.
     * @example
     * // Count the number of Roles_KhachHangs
     * const count = await prisma.roles_KhachHang.count({
     *   where: {
     *     // ... the filter for the Roles_KhachHangs we want to count
     *   }
     * })
    **/
    count<T extends Roles_KhachHangCountArgs>(
      args?: Subset<T, Roles_KhachHangCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Roles_KhachHangCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles_KhachHang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Roles_KhachHangAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Roles_KhachHangAggregateArgs>(args: Subset<T, Roles_KhachHangAggregateArgs>): Prisma.PrismaPromise<GetRoles_KhachHangAggregateType<T>>

    /**
     * Group by Roles_KhachHang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Roles_KhachHangGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Roles_KhachHangGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Roles_KhachHangGroupByArgs['orderBy'] }
        : { orderBy?: Roles_KhachHangGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Roles_KhachHangGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoles_KhachHangGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Roles_KhachHang model
   */
  readonly fields: Roles_KhachHangFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roles_KhachHang.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Roles_KhachHangClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_khachhang<T extends Roles_KhachHang$users_khachhangArgs<ExtArgs> = {}>(args?: Subset<T, Roles_KhachHang$users_khachhangArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Users_KhachHangPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Roles_KhachHang model
   */ 
  interface Roles_KhachHangFieldRefs {
    readonly id_role_KhachHang: FieldRef<"Roles_KhachHang", 'String'>
    readonly id_rkh: FieldRef<"Roles_KhachHang", 'String'>
    readonly name: FieldRef<"Roles_KhachHang", 'String'>
    readonly description: FieldRef<"Roles_KhachHang", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Roles_KhachHang findUnique
   */
  export type Roles_KhachHangFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_KhachHang
     */
    select?: Roles_KhachHangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_KhachHangInclude<ExtArgs> | null
    /**
     * Filter, which Roles_KhachHang to fetch.
     */
    where: Roles_KhachHangWhereUniqueInput
  }

  /**
   * Roles_KhachHang findUniqueOrThrow
   */
  export type Roles_KhachHangFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_KhachHang
     */
    select?: Roles_KhachHangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_KhachHangInclude<ExtArgs> | null
    /**
     * Filter, which Roles_KhachHang to fetch.
     */
    where: Roles_KhachHangWhereUniqueInput
  }

  /**
   * Roles_KhachHang findFirst
   */
  export type Roles_KhachHangFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_KhachHang
     */
    select?: Roles_KhachHangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_KhachHangInclude<ExtArgs> | null
    /**
     * Filter, which Roles_KhachHang to fetch.
     */
    where?: Roles_KhachHangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles_KhachHangs to fetch.
     */
    orderBy?: Roles_KhachHangOrderByWithRelationInput | Roles_KhachHangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles_KhachHangs.
     */
    cursor?: Roles_KhachHangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles_KhachHangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles_KhachHangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles_KhachHangs.
     */
    distinct?: Roles_KhachHangScalarFieldEnum | Roles_KhachHangScalarFieldEnum[]
  }

  /**
   * Roles_KhachHang findFirstOrThrow
   */
  export type Roles_KhachHangFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_KhachHang
     */
    select?: Roles_KhachHangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_KhachHangInclude<ExtArgs> | null
    /**
     * Filter, which Roles_KhachHang to fetch.
     */
    where?: Roles_KhachHangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles_KhachHangs to fetch.
     */
    orderBy?: Roles_KhachHangOrderByWithRelationInput | Roles_KhachHangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles_KhachHangs.
     */
    cursor?: Roles_KhachHangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles_KhachHangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles_KhachHangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles_KhachHangs.
     */
    distinct?: Roles_KhachHangScalarFieldEnum | Roles_KhachHangScalarFieldEnum[]
  }

  /**
   * Roles_KhachHang findMany
   */
  export type Roles_KhachHangFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_KhachHang
     */
    select?: Roles_KhachHangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_KhachHangInclude<ExtArgs> | null
    /**
     * Filter, which Roles_KhachHangs to fetch.
     */
    where?: Roles_KhachHangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles_KhachHangs to fetch.
     */
    orderBy?: Roles_KhachHangOrderByWithRelationInput | Roles_KhachHangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles_KhachHangs.
     */
    cursor?: Roles_KhachHangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles_KhachHangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles_KhachHangs.
     */
    skip?: number
    distinct?: Roles_KhachHangScalarFieldEnum | Roles_KhachHangScalarFieldEnum[]
  }

  /**
   * Roles_KhachHang create
   */
  export type Roles_KhachHangCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_KhachHang
     */
    select?: Roles_KhachHangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_KhachHangInclude<ExtArgs> | null
    /**
     * The data needed to create a Roles_KhachHang.
     */
    data: XOR<Roles_KhachHangCreateInput, Roles_KhachHangUncheckedCreateInput>
  }

  /**
   * Roles_KhachHang createMany
   */
  export type Roles_KhachHangCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles_KhachHangs.
     */
    data: Roles_KhachHangCreateManyInput | Roles_KhachHangCreateManyInput[]
  }

  /**
   * Roles_KhachHang update
   */
  export type Roles_KhachHangUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_KhachHang
     */
    select?: Roles_KhachHangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_KhachHangInclude<ExtArgs> | null
    /**
     * The data needed to update a Roles_KhachHang.
     */
    data: XOR<Roles_KhachHangUpdateInput, Roles_KhachHangUncheckedUpdateInput>
    /**
     * Choose, which Roles_KhachHang to update.
     */
    where: Roles_KhachHangWhereUniqueInput
  }

  /**
   * Roles_KhachHang updateMany
   */
  export type Roles_KhachHangUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles_KhachHangs.
     */
    data: XOR<Roles_KhachHangUpdateManyMutationInput, Roles_KhachHangUncheckedUpdateManyInput>
    /**
     * Filter which Roles_KhachHangs to update
     */
    where?: Roles_KhachHangWhereInput
  }

  /**
   * Roles_KhachHang upsert
   */
  export type Roles_KhachHangUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_KhachHang
     */
    select?: Roles_KhachHangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_KhachHangInclude<ExtArgs> | null
    /**
     * The filter to search for the Roles_KhachHang to update in case it exists.
     */
    where: Roles_KhachHangWhereUniqueInput
    /**
     * In case the Roles_KhachHang found by the `where` argument doesn't exist, create a new Roles_KhachHang with this data.
     */
    create: XOR<Roles_KhachHangCreateInput, Roles_KhachHangUncheckedCreateInput>
    /**
     * In case the Roles_KhachHang was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Roles_KhachHangUpdateInput, Roles_KhachHangUncheckedUpdateInput>
  }

  /**
   * Roles_KhachHang delete
   */
  export type Roles_KhachHangDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_KhachHang
     */
    select?: Roles_KhachHangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_KhachHangInclude<ExtArgs> | null
    /**
     * Filter which Roles_KhachHang to delete.
     */
    where: Roles_KhachHangWhereUniqueInput
  }

  /**
   * Roles_KhachHang deleteMany
   */
  export type Roles_KhachHangDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles_KhachHangs to delete
     */
    where?: Roles_KhachHangWhereInput
  }

  /**
   * Roles_KhachHang findRaw
   */
  export type Roles_KhachHangFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Roles_KhachHang aggregateRaw
   */
  export type Roles_KhachHangAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Roles_KhachHang.users_khachhang
   */
  export type Roles_KhachHang$users_khachhangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_KhachHang
     */
    select?: Users_KhachHangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_KhachHangInclude<ExtArgs> | null
    where?: Users_KhachHangWhereInput
    orderBy?: Users_KhachHangOrderByWithRelationInput | Users_KhachHangOrderByWithRelationInput[]
    cursor?: Users_KhachHangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Users_KhachHangScalarFieldEnum | Users_KhachHangScalarFieldEnum[]
  }

  /**
   * Roles_KhachHang without action
   */
  export type Roles_KhachHangDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_KhachHang
     */
    select?: Roles_KhachHangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_KhachHangInclude<ExtArgs> | null
  }


  /**
   * Model Roles_Staff
   */

  export type AggregateRoles_Staff = {
    _count: Roles_StaffCountAggregateOutputType | null
    _min: Roles_StaffMinAggregateOutputType | null
    _max: Roles_StaffMaxAggregateOutputType | null
  }

  export type Roles_StaffMinAggregateOutputType = {
    id_role_staff: string | null
    id_rt: string | null
    name: string | null
    description: string | null
  }

  export type Roles_StaffMaxAggregateOutputType = {
    id_role_staff: string | null
    id_rt: string | null
    name: string | null
    description: string | null
  }

  export type Roles_StaffCountAggregateOutputType = {
    id_role_staff: number
    id_rt: number
    name: number
    description: number
    _all: number
  }


  export type Roles_StaffMinAggregateInputType = {
    id_role_staff?: true
    id_rt?: true
    name?: true
    description?: true
  }

  export type Roles_StaffMaxAggregateInputType = {
    id_role_staff?: true
    id_rt?: true
    name?: true
    description?: true
  }

  export type Roles_StaffCountAggregateInputType = {
    id_role_staff?: true
    id_rt?: true
    name?: true
    description?: true
    _all?: true
  }

  export type Roles_StaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles_Staff to aggregate.
     */
    where?: Roles_StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles_Staffs to fetch.
     */
    orderBy?: Roles_StaffOrderByWithRelationInput | Roles_StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Roles_StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles_Staffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles_Staffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles_Staffs
    **/
    _count?: true | Roles_StaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Roles_StaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Roles_StaffMaxAggregateInputType
  }

  export type GetRoles_StaffAggregateType<T extends Roles_StaffAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles_Staff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles_Staff[P]>
      : GetScalarType<T[P], AggregateRoles_Staff[P]>
  }




  export type Roles_StaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Roles_StaffWhereInput
    orderBy?: Roles_StaffOrderByWithAggregationInput | Roles_StaffOrderByWithAggregationInput[]
    by: Roles_StaffScalarFieldEnum[] | Roles_StaffScalarFieldEnum
    having?: Roles_StaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Roles_StaffCountAggregateInputType | true
    _min?: Roles_StaffMinAggregateInputType
    _max?: Roles_StaffMaxAggregateInputType
  }

  export type Roles_StaffGroupByOutputType = {
    id_role_staff: string
    id_rt: string
    name: string
    description: string | null
    _count: Roles_StaffCountAggregateOutputType | null
    _min: Roles_StaffMinAggregateOutputType | null
    _max: Roles_StaffMaxAggregateOutputType | null
  }

  type GetRoles_StaffGroupByPayload<T extends Roles_StaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Roles_StaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Roles_StaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Roles_StaffGroupByOutputType[P]>
            : GetScalarType<T[P], Roles_StaffGroupByOutputType[P]>
        }
      >
    >


  export type Roles_StaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_role_staff?: boolean
    id_rt?: boolean
    name?: boolean
    description?: boolean
    users_staff?: boolean | Roles_Staff$users_staffArgs<ExtArgs>
    _count?: boolean | Roles_StaffCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles_Staff"]>


  export type Roles_StaffSelectScalar = {
    id_role_staff?: boolean
    id_rt?: boolean
    name?: boolean
    description?: boolean
  }

  export type Roles_StaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_staff?: boolean | Roles_Staff$users_staffArgs<ExtArgs>
    _count?: boolean | Roles_StaffCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $Roles_StaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Roles_Staff"
    objects: {
      /**
       * các liên kết bảng khác và dùng để dễ truy vấn
       */
      users_staff: Prisma.$Users_StaffPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_role_staff: string
      id_rt: string
      name: string
      description: string | null
    }, ExtArgs["result"]["roles_Staff"]>
    composites: {}
  }

  type Roles_StaffGetPayload<S extends boolean | null | undefined | Roles_StaffDefaultArgs> = $Result.GetResult<Prisma.$Roles_StaffPayload, S>

  type Roles_StaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Roles_StaffFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Roles_StaffCountAggregateInputType | true
    }

  export interface Roles_StaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roles_Staff'], meta: { name: 'Roles_Staff' } }
    /**
     * Find zero or one Roles_Staff that matches the filter.
     * @param {Roles_StaffFindUniqueArgs} args - Arguments to find a Roles_Staff
     * @example
     * // Get one Roles_Staff
     * const roles_Staff = await prisma.roles_Staff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Roles_StaffFindUniqueArgs>(args: SelectSubset<T, Roles_StaffFindUniqueArgs<ExtArgs>>): Prisma__Roles_StaffClient<$Result.GetResult<Prisma.$Roles_StaffPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Roles_Staff that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Roles_StaffFindUniqueOrThrowArgs} args - Arguments to find a Roles_Staff
     * @example
     * // Get one Roles_Staff
     * const roles_Staff = await prisma.roles_Staff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Roles_StaffFindUniqueOrThrowArgs>(args: SelectSubset<T, Roles_StaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Roles_StaffClient<$Result.GetResult<Prisma.$Roles_StaffPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Roles_Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Roles_StaffFindFirstArgs} args - Arguments to find a Roles_Staff
     * @example
     * // Get one Roles_Staff
     * const roles_Staff = await prisma.roles_Staff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Roles_StaffFindFirstArgs>(args?: SelectSubset<T, Roles_StaffFindFirstArgs<ExtArgs>>): Prisma__Roles_StaffClient<$Result.GetResult<Prisma.$Roles_StaffPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Roles_Staff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Roles_StaffFindFirstOrThrowArgs} args - Arguments to find a Roles_Staff
     * @example
     * // Get one Roles_Staff
     * const roles_Staff = await prisma.roles_Staff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Roles_StaffFindFirstOrThrowArgs>(args?: SelectSubset<T, Roles_StaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__Roles_StaffClient<$Result.GetResult<Prisma.$Roles_StaffPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles_Staffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Roles_StaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles_Staffs
     * const roles_Staffs = await prisma.roles_Staff.findMany()
     * 
     * // Get first 10 Roles_Staffs
     * const roles_Staffs = await prisma.roles_Staff.findMany({ take: 10 })
     * 
     * // Only select the `id_role_staff`
     * const roles_StaffWithId_role_staffOnly = await prisma.roles_Staff.findMany({ select: { id_role_staff: true } })
     * 
     */
    findMany<T extends Roles_StaffFindManyArgs>(args?: SelectSubset<T, Roles_StaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Roles_StaffPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Roles_Staff.
     * @param {Roles_StaffCreateArgs} args - Arguments to create a Roles_Staff.
     * @example
     * // Create one Roles_Staff
     * const Roles_Staff = await prisma.roles_Staff.create({
     *   data: {
     *     // ... data to create a Roles_Staff
     *   }
     * })
     * 
     */
    create<T extends Roles_StaffCreateArgs>(args: SelectSubset<T, Roles_StaffCreateArgs<ExtArgs>>): Prisma__Roles_StaffClient<$Result.GetResult<Prisma.$Roles_StaffPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles_Staffs.
     * @param {Roles_StaffCreateManyArgs} args - Arguments to create many Roles_Staffs.
     * @example
     * // Create many Roles_Staffs
     * const roles_Staff = await prisma.roles_Staff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Roles_StaffCreateManyArgs>(args?: SelectSubset<T, Roles_StaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roles_Staff.
     * @param {Roles_StaffDeleteArgs} args - Arguments to delete one Roles_Staff.
     * @example
     * // Delete one Roles_Staff
     * const Roles_Staff = await prisma.roles_Staff.delete({
     *   where: {
     *     // ... filter to delete one Roles_Staff
     *   }
     * })
     * 
     */
    delete<T extends Roles_StaffDeleteArgs>(args: SelectSubset<T, Roles_StaffDeleteArgs<ExtArgs>>): Prisma__Roles_StaffClient<$Result.GetResult<Prisma.$Roles_StaffPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Roles_Staff.
     * @param {Roles_StaffUpdateArgs} args - Arguments to update one Roles_Staff.
     * @example
     * // Update one Roles_Staff
     * const roles_Staff = await prisma.roles_Staff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Roles_StaffUpdateArgs>(args: SelectSubset<T, Roles_StaffUpdateArgs<ExtArgs>>): Prisma__Roles_StaffClient<$Result.GetResult<Prisma.$Roles_StaffPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles_Staffs.
     * @param {Roles_StaffDeleteManyArgs} args - Arguments to filter Roles_Staffs to delete.
     * @example
     * // Delete a few Roles_Staffs
     * const { count } = await prisma.roles_Staff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Roles_StaffDeleteManyArgs>(args?: SelectSubset<T, Roles_StaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles_Staffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Roles_StaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles_Staffs
     * const roles_Staff = await prisma.roles_Staff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Roles_StaffUpdateManyArgs>(args: SelectSubset<T, Roles_StaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles_Staff.
     * @param {Roles_StaffUpsertArgs} args - Arguments to update or create a Roles_Staff.
     * @example
     * // Update or create a Roles_Staff
     * const roles_Staff = await prisma.roles_Staff.upsert({
     *   create: {
     *     // ... data to create a Roles_Staff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles_Staff we want to update
     *   }
     * })
     */
    upsert<T extends Roles_StaffUpsertArgs>(args: SelectSubset<T, Roles_StaffUpsertArgs<ExtArgs>>): Prisma__Roles_StaffClient<$Result.GetResult<Prisma.$Roles_StaffPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Roles_Staffs that matches the filter.
     * @param {Roles_StaffFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const roles_Staff = await prisma.roles_Staff.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: Roles_StaffFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Roles_Staff.
     * @param {Roles_StaffAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const roles_Staff = await prisma.roles_Staff.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: Roles_StaffAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Roles_Staffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Roles_StaffCountArgs} args - Arguments to filter Roles_Staffs to count.
     * @example
     * // Count the number of Roles_Staffs
     * const count = await prisma.roles_Staff.count({
     *   where: {
     *     // ... the filter for the Roles_Staffs we want to count
     *   }
     * })
    **/
    count<T extends Roles_StaffCountArgs>(
      args?: Subset<T, Roles_StaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Roles_StaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles_Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Roles_StaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Roles_StaffAggregateArgs>(args: Subset<T, Roles_StaffAggregateArgs>): Prisma.PrismaPromise<GetRoles_StaffAggregateType<T>>

    /**
     * Group by Roles_Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Roles_StaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Roles_StaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Roles_StaffGroupByArgs['orderBy'] }
        : { orderBy?: Roles_StaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Roles_StaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoles_StaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Roles_Staff model
   */
  readonly fields: Roles_StaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roles_Staff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Roles_StaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_staff<T extends Roles_Staff$users_staffArgs<ExtArgs> = {}>(args?: Subset<T, Roles_Staff$users_staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Users_StaffPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Roles_Staff model
   */ 
  interface Roles_StaffFieldRefs {
    readonly id_role_staff: FieldRef<"Roles_Staff", 'String'>
    readonly id_rt: FieldRef<"Roles_Staff", 'String'>
    readonly name: FieldRef<"Roles_Staff", 'String'>
    readonly description: FieldRef<"Roles_Staff", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Roles_Staff findUnique
   */
  export type Roles_StaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_Staff
     */
    select?: Roles_StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_StaffInclude<ExtArgs> | null
    /**
     * Filter, which Roles_Staff to fetch.
     */
    where: Roles_StaffWhereUniqueInput
  }

  /**
   * Roles_Staff findUniqueOrThrow
   */
  export type Roles_StaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_Staff
     */
    select?: Roles_StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_StaffInclude<ExtArgs> | null
    /**
     * Filter, which Roles_Staff to fetch.
     */
    where: Roles_StaffWhereUniqueInput
  }

  /**
   * Roles_Staff findFirst
   */
  export type Roles_StaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_Staff
     */
    select?: Roles_StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_StaffInclude<ExtArgs> | null
    /**
     * Filter, which Roles_Staff to fetch.
     */
    where?: Roles_StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles_Staffs to fetch.
     */
    orderBy?: Roles_StaffOrderByWithRelationInput | Roles_StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles_Staffs.
     */
    cursor?: Roles_StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles_Staffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles_Staffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles_Staffs.
     */
    distinct?: Roles_StaffScalarFieldEnum | Roles_StaffScalarFieldEnum[]
  }

  /**
   * Roles_Staff findFirstOrThrow
   */
  export type Roles_StaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_Staff
     */
    select?: Roles_StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_StaffInclude<ExtArgs> | null
    /**
     * Filter, which Roles_Staff to fetch.
     */
    where?: Roles_StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles_Staffs to fetch.
     */
    orderBy?: Roles_StaffOrderByWithRelationInput | Roles_StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles_Staffs.
     */
    cursor?: Roles_StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles_Staffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles_Staffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles_Staffs.
     */
    distinct?: Roles_StaffScalarFieldEnum | Roles_StaffScalarFieldEnum[]
  }

  /**
   * Roles_Staff findMany
   */
  export type Roles_StaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_Staff
     */
    select?: Roles_StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_StaffInclude<ExtArgs> | null
    /**
     * Filter, which Roles_Staffs to fetch.
     */
    where?: Roles_StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles_Staffs to fetch.
     */
    orderBy?: Roles_StaffOrderByWithRelationInput | Roles_StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles_Staffs.
     */
    cursor?: Roles_StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles_Staffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles_Staffs.
     */
    skip?: number
    distinct?: Roles_StaffScalarFieldEnum | Roles_StaffScalarFieldEnum[]
  }

  /**
   * Roles_Staff create
   */
  export type Roles_StaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_Staff
     */
    select?: Roles_StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_StaffInclude<ExtArgs> | null
    /**
     * The data needed to create a Roles_Staff.
     */
    data: XOR<Roles_StaffCreateInput, Roles_StaffUncheckedCreateInput>
  }

  /**
   * Roles_Staff createMany
   */
  export type Roles_StaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles_Staffs.
     */
    data: Roles_StaffCreateManyInput | Roles_StaffCreateManyInput[]
  }

  /**
   * Roles_Staff update
   */
  export type Roles_StaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_Staff
     */
    select?: Roles_StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_StaffInclude<ExtArgs> | null
    /**
     * The data needed to update a Roles_Staff.
     */
    data: XOR<Roles_StaffUpdateInput, Roles_StaffUncheckedUpdateInput>
    /**
     * Choose, which Roles_Staff to update.
     */
    where: Roles_StaffWhereUniqueInput
  }

  /**
   * Roles_Staff updateMany
   */
  export type Roles_StaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles_Staffs.
     */
    data: XOR<Roles_StaffUpdateManyMutationInput, Roles_StaffUncheckedUpdateManyInput>
    /**
     * Filter which Roles_Staffs to update
     */
    where?: Roles_StaffWhereInput
  }

  /**
   * Roles_Staff upsert
   */
  export type Roles_StaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_Staff
     */
    select?: Roles_StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_StaffInclude<ExtArgs> | null
    /**
     * The filter to search for the Roles_Staff to update in case it exists.
     */
    where: Roles_StaffWhereUniqueInput
    /**
     * In case the Roles_Staff found by the `where` argument doesn't exist, create a new Roles_Staff with this data.
     */
    create: XOR<Roles_StaffCreateInput, Roles_StaffUncheckedCreateInput>
    /**
     * In case the Roles_Staff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Roles_StaffUpdateInput, Roles_StaffUncheckedUpdateInput>
  }

  /**
   * Roles_Staff delete
   */
  export type Roles_StaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_Staff
     */
    select?: Roles_StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_StaffInclude<ExtArgs> | null
    /**
     * Filter which Roles_Staff to delete.
     */
    where: Roles_StaffWhereUniqueInput
  }

  /**
   * Roles_Staff deleteMany
   */
  export type Roles_StaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles_Staffs to delete
     */
    where?: Roles_StaffWhereInput
  }

  /**
   * Roles_Staff findRaw
   */
  export type Roles_StaffFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Roles_Staff aggregateRaw
   */
  export type Roles_StaffAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Roles_Staff.users_staff
   */
  export type Roles_Staff$users_staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_Staff
     */
    select?: Users_StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_StaffInclude<ExtArgs> | null
    where?: Users_StaffWhereInput
    orderBy?: Users_StaffOrderByWithRelationInput | Users_StaffOrderByWithRelationInput[]
    cursor?: Users_StaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Users_StaffScalarFieldEnum | Users_StaffScalarFieldEnum[]
  }

  /**
   * Roles_Staff without action
   */
  export type Roles_StaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles_Staff
     */
    select?: Roles_StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Roles_StaffInclude<ExtArgs> | null
  }


  /**
   * Model Users_Admin
   */

  export type AggregateUsers_Admin = {
    _count: Users_AdminCountAggregateOutputType | null
    _min: Users_AdminMinAggregateOutputType | null
    _max: Users_AdminMaxAggregateOutputType | null
  }

  export type Users_AdminMinAggregateOutputType = {
    id_user_admin: string | null
    id_ud: string | null
    user_name: string | null
    name: string | null
    email: string | null
    phone: string | null
    password_hash: string | null
    google_id: string | null
    gender: $Enums.Gender | null
    date_of_birth: Date | null
    avatar: string | null
    id_role_admin: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Users_AdminMaxAggregateOutputType = {
    id_user_admin: string | null
    id_ud: string | null
    user_name: string | null
    name: string | null
    email: string | null
    phone: string | null
    password_hash: string | null
    google_id: string | null
    gender: $Enums.Gender | null
    date_of_birth: Date | null
    avatar: string | null
    id_role_admin: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Users_AdminCountAggregateOutputType = {
    id_user_admin: number
    id_ud: number
    user_name: number
    name: number
    email: number
    phone: number
    password_hash: number
    google_id: number
    gender: number
    date_of_birth: number
    avatar: number
    id_role_admin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Users_AdminMinAggregateInputType = {
    id_user_admin?: true
    id_ud?: true
    user_name?: true
    name?: true
    email?: true
    phone?: true
    password_hash?: true
    google_id?: true
    gender?: true
    date_of_birth?: true
    avatar?: true
    id_role_admin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Users_AdminMaxAggregateInputType = {
    id_user_admin?: true
    id_ud?: true
    user_name?: true
    name?: true
    email?: true
    phone?: true
    password_hash?: true
    google_id?: true
    gender?: true
    date_of_birth?: true
    avatar?: true
    id_role_admin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Users_AdminCountAggregateInputType = {
    id_user_admin?: true
    id_ud?: true
    user_name?: true
    name?: true
    email?: true
    phone?: true
    password_hash?: true
    google_id?: true
    gender?: true
    date_of_birth?: true
    avatar?: true
    id_role_admin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Users_AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users_Admin to aggregate.
     */
    where?: Users_AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users_Admins to fetch.
     */
    orderBy?: Users_AdminOrderByWithRelationInput | Users_AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Users_AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users_Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users_Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users_Admins
    **/
    _count?: true | Users_AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Users_AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Users_AdminMaxAggregateInputType
  }

  export type GetUsers_AdminAggregateType<T extends Users_AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers_Admin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers_Admin[P]>
      : GetScalarType<T[P], AggregateUsers_Admin[P]>
  }




  export type Users_AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Users_AdminWhereInput
    orderBy?: Users_AdminOrderByWithAggregationInput | Users_AdminOrderByWithAggregationInput[]
    by: Users_AdminScalarFieldEnum[] | Users_AdminScalarFieldEnum
    having?: Users_AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Users_AdminCountAggregateInputType | true
    _min?: Users_AdminMinAggregateInputType
    _max?: Users_AdminMaxAggregateInputType
  }

  export type Users_AdminGroupByOutputType = {
    id_user_admin: string
    id_ud: string
    user_name: string
    name: string | null
    email: string
    phone: string | null
    password_hash: string
    google_id: string | null
    gender: $Enums.Gender
    date_of_birth: Date
    avatar: string | null
    id_role_admin: string
    createdAt: Date
    updatedAt: Date
    _count: Users_AdminCountAggregateOutputType | null
    _min: Users_AdminMinAggregateOutputType | null
    _max: Users_AdminMaxAggregateOutputType | null
  }

  type GetUsers_AdminGroupByPayload<T extends Users_AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Users_AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Users_AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Users_AdminGroupByOutputType[P]>
            : GetScalarType<T[P], Users_AdminGroupByOutputType[P]>
        }
      >
    >


  export type Users_AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_user_admin?: boolean
    id_ud?: boolean
    user_name?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password_hash?: boolean
    google_id?: boolean
    gender?: boolean
    date_of_birth?: boolean
    avatar?: boolean
    id_role_admin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | Roles_AdminDefaultArgs<ExtArgs>
    owners_brand?: boolean | Users_Admin$owners_brandArgs<ExtArgs>
    _count?: boolean | Users_AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users_Admin"]>


  export type Users_AdminSelectScalar = {
    id_user_admin?: boolean
    id_ud?: boolean
    user_name?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password_hash?: boolean
    google_id?: boolean
    gender?: boolean
    date_of_birth?: boolean
    avatar?: boolean
    id_role_admin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type Users_AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | Roles_AdminDefaultArgs<ExtArgs>
    owners_brand?: boolean | Users_Admin$owners_brandArgs<ExtArgs>
    _count?: boolean | Users_AdminCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $Users_AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users_Admin"
    objects: {
      role: Prisma.$Roles_AdminPayload<ExtArgs>
      /**
       * các liên kết bảng khác và dùng để dễ truy vấn
       */
      owners_brand: Prisma.$Owners_BrandPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_user_admin: string
      id_ud: string
      user_name: string
      name: string | null
      email: string
      phone: string | null
      password_hash: string
      google_id: string | null
      gender: $Enums.Gender
      date_of_birth: Date
      avatar: string | null
      id_role_admin: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["users_Admin"]>
    composites: {}
  }

  type Users_AdminGetPayload<S extends boolean | null | undefined | Users_AdminDefaultArgs> = $Result.GetResult<Prisma.$Users_AdminPayload, S>

  type Users_AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Users_AdminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Users_AdminCountAggregateInputType | true
    }

  export interface Users_AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users_Admin'], meta: { name: 'Users_Admin' } }
    /**
     * Find zero or one Users_Admin that matches the filter.
     * @param {Users_AdminFindUniqueArgs} args - Arguments to find a Users_Admin
     * @example
     * // Get one Users_Admin
     * const users_Admin = await prisma.users_Admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Users_AdminFindUniqueArgs>(args: SelectSubset<T, Users_AdminFindUniqueArgs<ExtArgs>>): Prisma__Users_AdminClient<$Result.GetResult<Prisma.$Users_AdminPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users_Admin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Users_AdminFindUniqueOrThrowArgs} args - Arguments to find a Users_Admin
     * @example
     * // Get one Users_Admin
     * const users_Admin = await prisma.users_Admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Users_AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, Users_AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Users_AdminClient<$Result.GetResult<Prisma.$Users_AdminPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users_Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_AdminFindFirstArgs} args - Arguments to find a Users_Admin
     * @example
     * // Get one Users_Admin
     * const users_Admin = await prisma.users_Admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Users_AdminFindFirstArgs>(args?: SelectSubset<T, Users_AdminFindFirstArgs<ExtArgs>>): Prisma__Users_AdminClient<$Result.GetResult<Prisma.$Users_AdminPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users_Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_AdminFindFirstOrThrowArgs} args - Arguments to find a Users_Admin
     * @example
     * // Get one Users_Admin
     * const users_Admin = await prisma.users_Admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Users_AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, Users_AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__Users_AdminClient<$Result.GetResult<Prisma.$Users_AdminPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users_Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users_Admins
     * const users_Admins = await prisma.users_Admin.findMany()
     * 
     * // Get first 10 Users_Admins
     * const users_Admins = await prisma.users_Admin.findMany({ take: 10 })
     * 
     * // Only select the `id_user_admin`
     * const users_AdminWithId_user_adminOnly = await prisma.users_Admin.findMany({ select: { id_user_admin: true } })
     * 
     */
    findMany<T extends Users_AdminFindManyArgs>(args?: SelectSubset<T, Users_AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Users_AdminPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users_Admin.
     * @param {Users_AdminCreateArgs} args - Arguments to create a Users_Admin.
     * @example
     * // Create one Users_Admin
     * const Users_Admin = await prisma.users_Admin.create({
     *   data: {
     *     // ... data to create a Users_Admin
     *   }
     * })
     * 
     */
    create<T extends Users_AdminCreateArgs>(args: SelectSubset<T, Users_AdminCreateArgs<ExtArgs>>): Prisma__Users_AdminClient<$Result.GetResult<Prisma.$Users_AdminPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users_Admins.
     * @param {Users_AdminCreateManyArgs} args - Arguments to create many Users_Admins.
     * @example
     * // Create many Users_Admins
     * const users_Admin = await prisma.users_Admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Users_AdminCreateManyArgs>(args?: SelectSubset<T, Users_AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users_Admin.
     * @param {Users_AdminDeleteArgs} args - Arguments to delete one Users_Admin.
     * @example
     * // Delete one Users_Admin
     * const Users_Admin = await prisma.users_Admin.delete({
     *   where: {
     *     // ... filter to delete one Users_Admin
     *   }
     * })
     * 
     */
    delete<T extends Users_AdminDeleteArgs>(args: SelectSubset<T, Users_AdminDeleteArgs<ExtArgs>>): Prisma__Users_AdminClient<$Result.GetResult<Prisma.$Users_AdminPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users_Admin.
     * @param {Users_AdminUpdateArgs} args - Arguments to update one Users_Admin.
     * @example
     * // Update one Users_Admin
     * const users_Admin = await prisma.users_Admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Users_AdminUpdateArgs>(args: SelectSubset<T, Users_AdminUpdateArgs<ExtArgs>>): Prisma__Users_AdminClient<$Result.GetResult<Prisma.$Users_AdminPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users_Admins.
     * @param {Users_AdminDeleteManyArgs} args - Arguments to filter Users_Admins to delete.
     * @example
     * // Delete a few Users_Admins
     * const { count } = await prisma.users_Admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Users_AdminDeleteManyArgs>(args?: SelectSubset<T, Users_AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users_Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users_Admins
     * const users_Admin = await prisma.users_Admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Users_AdminUpdateManyArgs>(args: SelectSubset<T, Users_AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users_Admin.
     * @param {Users_AdminUpsertArgs} args - Arguments to update or create a Users_Admin.
     * @example
     * // Update or create a Users_Admin
     * const users_Admin = await prisma.users_Admin.upsert({
     *   create: {
     *     // ... data to create a Users_Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users_Admin we want to update
     *   }
     * })
     */
    upsert<T extends Users_AdminUpsertArgs>(args: SelectSubset<T, Users_AdminUpsertArgs<ExtArgs>>): Prisma__Users_AdminClient<$Result.GetResult<Prisma.$Users_AdminPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Users_Admins that matches the filter.
     * @param {Users_AdminFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const users_Admin = await prisma.users_Admin.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: Users_AdminFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Users_Admin.
     * @param {Users_AdminAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const users_Admin = await prisma.users_Admin.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: Users_AdminAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users_Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_AdminCountArgs} args - Arguments to filter Users_Admins to count.
     * @example
     * // Count the number of Users_Admins
     * const count = await prisma.users_Admin.count({
     *   where: {
     *     // ... the filter for the Users_Admins we want to count
     *   }
     * })
    **/
    count<T extends Users_AdminCountArgs>(
      args?: Subset<T, Users_AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Users_AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users_Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Users_AdminAggregateArgs>(args: Subset<T, Users_AdminAggregateArgs>): Prisma.PrismaPromise<GetUsers_AdminAggregateType<T>>

    /**
     * Group by Users_Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Users_AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Users_AdminGroupByArgs['orderBy'] }
        : { orderBy?: Users_AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Users_AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsers_AdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users_Admin model
   */
  readonly fields: Users_AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users_Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Users_AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends Roles_AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Roles_AdminDefaultArgs<ExtArgs>>): Prisma__Roles_AdminClient<$Result.GetResult<Prisma.$Roles_AdminPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    owners_brand<T extends Users_Admin$owners_brandArgs<ExtArgs> = {}>(args?: Subset<T, Users_Admin$owners_brandArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Owners_BrandPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users_Admin model
   */ 
  interface Users_AdminFieldRefs {
    readonly id_user_admin: FieldRef<"Users_Admin", 'String'>
    readonly id_ud: FieldRef<"Users_Admin", 'String'>
    readonly user_name: FieldRef<"Users_Admin", 'String'>
    readonly name: FieldRef<"Users_Admin", 'String'>
    readonly email: FieldRef<"Users_Admin", 'String'>
    readonly phone: FieldRef<"Users_Admin", 'String'>
    readonly password_hash: FieldRef<"Users_Admin", 'String'>
    readonly google_id: FieldRef<"Users_Admin", 'String'>
    readonly gender: FieldRef<"Users_Admin", 'Gender'>
    readonly date_of_birth: FieldRef<"Users_Admin", 'DateTime'>
    readonly avatar: FieldRef<"Users_Admin", 'String'>
    readonly id_role_admin: FieldRef<"Users_Admin", 'String'>
    readonly createdAt: FieldRef<"Users_Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Users_Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Users_Admin findUnique
   */
  export type Users_AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_Admin
     */
    select?: Users_AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_AdminInclude<ExtArgs> | null
    /**
     * Filter, which Users_Admin to fetch.
     */
    where: Users_AdminWhereUniqueInput
  }

  /**
   * Users_Admin findUniqueOrThrow
   */
  export type Users_AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_Admin
     */
    select?: Users_AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_AdminInclude<ExtArgs> | null
    /**
     * Filter, which Users_Admin to fetch.
     */
    where: Users_AdminWhereUniqueInput
  }

  /**
   * Users_Admin findFirst
   */
  export type Users_AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_Admin
     */
    select?: Users_AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_AdminInclude<ExtArgs> | null
    /**
     * Filter, which Users_Admin to fetch.
     */
    where?: Users_AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users_Admins to fetch.
     */
    orderBy?: Users_AdminOrderByWithRelationInput | Users_AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users_Admins.
     */
    cursor?: Users_AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users_Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users_Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users_Admins.
     */
    distinct?: Users_AdminScalarFieldEnum | Users_AdminScalarFieldEnum[]
  }

  /**
   * Users_Admin findFirstOrThrow
   */
  export type Users_AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_Admin
     */
    select?: Users_AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_AdminInclude<ExtArgs> | null
    /**
     * Filter, which Users_Admin to fetch.
     */
    where?: Users_AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users_Admins to fetch.
     */
    orderBy?: Users_AdminOrderByWithRelationInput | Users_AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users_Admins.
     */
    cursor?: Users_AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users_Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users_Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users_Admins.
     */
    distinct?: Users_AdminScalarFieldEnum | Users_AdminScalarFieldEnum[]
  }

  /**
   * Users_Admin findMany
   */
  export type Users_AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_Admin
     */
    select?: Users_AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_AdminInclude<ExtArgs> | null
    /**
     * Filter, which Users_Admins to fetch.
     */
    where?: Users_AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users_Admins to fetch.
     */
    orderBy?: Users_AdminOrderByWithRelationInput | Users_AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users_Admins.
     */
    cursor?: Users_AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users_Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users_Admins.
     */
    skip?: number
    distinct?: Users_AdminScalarFieldEnum | Users_AdminScalarFieldEnum[]
  }

  /**
   * Users_Admin create
   */
  export type Users_AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_Admin
     */
    select?: Users_AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Users_Admin.
     */
    data: XOR<Users_AdminCreateInput, Users_AdminUncheckedCreateInput>
  }

  /**
   * Users_Admin createMany
   */
  export type Users_AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users_Admins.
     */
    data: Users_AdminCreateManyInput | Users_AdminCreateManyInput[]
  }

  /**
   * Users_Admin update
   */
  export type Users_AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_Admin
     */
    select?: Users_AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Users_Admin.
     */
    data: XOR<Users_AdminUpdateInput, Users_AdminUncheckedUpdateInput>
    /**
     * Choose, which Users_Admin to update.
     */
    where: Users_AdminWhereUniqueInput
  }

  /**
   * Users_Admin updateMany
   */
  export type Users_AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users_Admins.
     */
    data: XOR<Users_AdminUpdateManyMutationInput, Users_AdminUncheckedUpdateManyInput>
    /**
     * Filter which Users_Admins to update
     */
    where?: Users_AdminWhereInput
  }

  /**
   * Users_Admin upsert
   */
  export type Users_AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_Admin
     */
    select?: Users_AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Users_Admin to update in case it exists.
     */
    where: Users_AdminWhereUniqueInput
    /**
     * In case the Users_Admin found by the `where` argument doesn't exist, create a new Users_Admin with this data.
     */
    create: XOR<Users_AdminCreateInput, Users_AdminUncheckedCreateInput>
    /**
     * In case the Users_Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Users_AdminUpdateInput, Users_AdminUncheckedUpdateInput>
  }

  /**
   * Users_Admin delete
   */
  export type Users_AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_Admin
     */
    select?: Users_AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_AdminInclude<ExtArgs> | null
    /**
     * Filter which Users_Admin to delete.
     */
    where: Users_AdminWhereUniqueInput
  }

  /**
   * Users_Admin deleteMany
   */
  export type Users_AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users_Admins to delete
     */
    where?: Users_AdminWhereInput
  }

  /**
   * Users_Admin findRaw
   */
  export type Users_AdminFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Users_Admin aggregateRaw
   */
  export type Users_AdminAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Users_Admin.owners_brand
   */
  export type Users_Admin$owners_brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owners_Brand
     */
    select?: Owners_BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Owners_BrandInclude<ExtArgs> | null
    where?: Owners_BrandWhereInput
    orderBy?: Owners_BrandOrderByWithRelationInput | Owners_BrandOrderByWithRelationInput[]
    cursor?: Owners_BrandWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Owners_BrandScalarFieldEnum | Owners_BrandScalarFieldEnum[]
  }

  /**
   * Users_Admin without action
   */
  export type Users_AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_Admin
     */
    select?: Users_AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_AdminInclude<ExtArgs> | null
  }


  /**
   * Model Users_KhachHang
   */

  export type AggregateUsers_KhachHang = {
    _count: Users_KhachHangCountAggregateOutputType | null
    _min: Users_KhachHangMinAggregateOutputType | null
    _max: Users_KhachHangMaxAggregateOutputType | null
  }

  export type Users_KhachHangMinAggregateOutputType = {
    id_user_KhachHang: string | null
    id_uk: string | null
    user_name: string | null
    name: string | null
    email: string | null
    phone: string | null
    google_id: string | null
    gender: $Enums.Gender | null
    date_of_birth: Date | null
    avatar: string | null
    createdAt: Date | null
    updatedAt: Date | null
    id_role_KhachHang: string | null
  }

  export type Users_KhachHangMaxAggregateOutputType = {
    id_user_KhachHang: string | null
    id_uk: string | null
    user_name: string | null
    name: string | null
    email: string | null
    phone: string | null
    google_id: string | null
    gender: $Enums.Gender | null
    date_of_birth: Date | null
    avatar: string | null
    createdAt: Date | null
    updatedAt: Date | null
    id_role_KhachHang: string | null
  }

  export type Users_KhachHangCountAggregateOutputType = {
    id_user_KhachHang: number
    id_uk: number
    user_name: number
    name: number
    email: number
    phone: number
    google_id: number
    gender: number
    date_of_birth: number
    avatar: number
    createdAt: number
    updatedAt: number
    id_role_KhachHang: number
    _all: number
  }


  export type Users_KhachHangMinAggregateInputType = {
    id_user_KhachHang?: true
    id_uk?: true
    user_name?: true
    name?: true
    email?: true
    phone?: true
    google_id?: true
    gender?: true
    date_of_birth?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
    id_role_KhachHang?: true
  }

  export type Users_KhachHangMaxAggregateInputType = {
    id_user_KhachHang?: true
    id_uk?: true
    user_name?: true
    name?: true
    email?: true
    phone?: true
    google_id?: true
    gender?: true
    date_of_birth?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
    id_role_KhachHang?: true
  }

  export type Users_KhachHangCountAggregateInputType = {
    id_user_KhachHang?: true
    id_uk?: true
    user_name?: true
    name?: true
    email?: true
    phone?: true
    google_id?: true
    gender?: true
    date_of_birth?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
    id_role_KhachHang?: true
    _all?: true
  }

  export type Users_KhachHangAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users_KhachHang to aggregate.
     */
    where?: Users_KhachHangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users_KhachHangs to fetch.
     */
    orderBy?: Users_KhachHangOrderByWithRelationInput | Users_KhachHangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Users_KhachHangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users_KhachHangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users_KhachHangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users_KhachHangs
    **/
    _count?: true | Users_KhachHangCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Users_KhachHangMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Users_KhachHangMaxAggregateInputType
  }

  export type GetUsers_KhachHangAggregateType<T extends Users_KhachHangAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers_KhachHang]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers_KhachHang[P]>
      : GetScalarType<T[P], AggregateUsers_KhachHang[P]>
  }




  export type Users_KhachHangGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Users_KhachHangWhereInput
    orderBy?: Users_KhachHangOrderByWithAggregationInput | Users_KhachHangOrderByWithAggregationInput[]
    by: Users_KhachHangScalarFieldEnum[] | Users_KhachHangScalarFieldEnum
    having?: Users_KhachHangScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Users_KhachHangCountAggregateInputType | true
    _min?: Users_KhachHangMinAggregateInputType
    _max?: Users_KhachHangMaxAggregateInputType
  }

  export type Users_KhachHangGroupByOutputType = {
    id_user_KhachHang: string
    id_uk: string
    user_name: string
    name: string | null
    email: string
    phone: string | null
    google_id: string | null
    gender: $Enums.Gender
    date_of_birth: Date
    avatar: string | null
    createdAt: Date
    updatedAt: Date
    id_role_KhachHang: string
    _count: Users_KhachHangCountAggregateOutputType | null
    _min: Users_KhachHangMinAggregateOutputType | null
    _max: Users_KhachHangMaxAggregateOutputType | null
  }

  type GetUsers_KhachHangGroupByPayload<T extends Users_KhachHangGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Users_KhachHangGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Users_KhachHangGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Users_KhachHangGroupByOutputType[P]>
            : GetScalarType<T[P], Users_KhachHangGroupByOutputType[P]>
        }
      >
    >


  export type Users_KhachHangSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_user_KhachHang?: boolean
    id_uk?: boolean
    user_name?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    google_id?: boolean
    gender?: boolean
    date_of_birth?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id_role_KhachHang?: boolean
    role?: boolean | Roles_KhachHangDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users_KhachHang"]>


  export type Users_KhachHangSelectScalar = {
    id_user_KhachHang?: boolean
    id_uk?: boolean
    user_name?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    google_id?: boolean
    gender?: boolean
    date_of_birth?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id_role_KhachHang?: boolean
  }

  export type Users_KhachHangInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | Roles_KhachHangDefaultArgs<ExtArgs>
  }

  export type $Users_KhachHangPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users_KhachHang"
    objects: {
      role: Prisma.$Roles_KhachHangPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_user_KhachHang: string
      id_uk: string
      user_name: string
      name: string | null
      email: string
      phone: string | null
      google_id: string | null
      gender: $Enums.Gender
      date_of_birth: Date
      avatar: string | null
      createdAt: Date
      updatedAt: Date
      id_role_KhachHang: string
    }, ExtArgs["result"]["users_KhachHang"]>
    composites: {}
  }

  type Users_KhachHangGetPayload<S extends boolean | null | undefined | Users_KhachHangDefaultArgs> = $Result.GetResult<Prisma.$Users_KhachHangPayload, S>

  type Users_KhachHangCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Users_KhachHangFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Users_KhachHangCountAggregateInputType | true
    }

  export interface Users_KhachHangDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users_KhachHang'], meta: { name: 'Users_KhachHang' } }
    /**
     * Find zero or one Users_KhachHang that matches the filter.
     * @param {Users_KhachHangFindUniqueArgs} args - Arguments to find a Users_KhachHang
     * @example
     * // Get one Users_KhachHang
     * const users_KhachHang = await prisma.users_KhachHang.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Users_KhachHangFindUniqueArgs>(args: SelectSubset<T, Users_KhachHangFindUniqueArgs<ExtArgs>>): Prisma__Users_KhachHangClient<$Result.GetResult<Prisma.$Users_KhachHangPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users_KhachHang that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Users_KhachHangFindUniqueOrThrowArgs} args - Arguments to find a Users_KhachHang
     * @example
     * // Get one Users_KhachHang
     * const users_KhachHang = await prisma.users_KhachHang.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Users_KhachHangFindUniqueOrThrowArgs>(args: SelectSubset<T, Users_KhachHangFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Users_KhachHangClient<$Result.GetResult<Prisma.$Users_KhachHangPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users_KhachHang that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_KhachHangFindFirstArgs} args - Arguments to find a Users_KhachHang
     * @example
     * // Get one Users_KhachHang
     * const users_KhachHang = await prisma.users_KhachHang.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Users_KhachHangFindFirstArgs>(args?: SelectSubset<T, Users_KhachHangFindFirstArgs<ExtArgs>>): Prisma__Users_KhachHangClient<$Result.GetResult<Prisma.$Users_KhachHangPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users_KhachHang that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_KhachHangFindFirstOrThrowArgs} args - Arguments to find a Users_KhachHang
     * @example
     * // Get one Users_KhachHang
     * const users_KhachHang = await prisma.users_KhachHang.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Users_KhachHangFindFirstOrThrowArgs>(args?: SelectSubset<T, Users_KhachHangFindFirstOrThrowArgs<ExtArgs>>): Prisma__Users_KhachHangClient<$Result.GetResult<Prisma.$Users_KhachHangPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users_KhachHangs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_KhachHangFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users_KhachHangs
     * const users_KhachHangs = await prisma.users_KhachHang.findMany()
     * 
     * // Get first 10 Users_KhachHangs
     * const users_KhachHangs = await prisma.users_KhachHang.findMany({ take: 10 })
     * 
     * // Only select the `id_user_KhachHang`
     * const users_KhachHangWithId_user_KhachHangOnly = await prisma.users_KhachHang.findMany({ select: { id_user_KhachHang: true } })
     * 
     */
    findMany<T extends Users_KhachHangFindManyArgs>(args?: SelectSubset<T, Users_KhachHangFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Users_KhachHangPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users_KhachHang.
     * @param {Users_KhachHangCreateArgs} args - Arguments to create a Users_KhachHang.
     * @example
     * // Create one Users_KhachHang
     * const Users_KhachHang = await prisma.users_KhachHang.create({
     *   data: {
     *     // ... data to create a Users_KhachHang
     *   }
     * })
     * 
     */
    create<T extends Users_KhachHangCreateArgs>(args: SelectSubset<T, Users_KhachHangCreateArgs<ExtArgs>>): Prisma__Users_KhachHangClient<$Result.GetResult<Prisma.$Users_KhachHangPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users_KhachHangs.
     * @param {Users_KhachHangCreateManyArgs} args - Arguments to create many Users_KhachHangs.
     * @example
     * // Create many Users_KhachHangs
     * const users_KhachHang = await prisma.users_KhachHang.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Users_KhachHangCreateManyArgs>(args?: SelectSubset<T, Users_KhachHangCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users_KhachHang.
     * @param {Users_KhachHangDeleteArgs} args - Arguments to delete one Users_KhachHang.
     * @example
     * // Delete one Users_KhachHang
     * const Users_KhachHang = await prisma.users_KhachHang.delete({
     *   where: {
     *     // ... filter to delete one Users_KhachHang
     *   }
     * })
     * 
     */
    delete<T extends Users_KhachHangDeleteArgs>(args: SelectSubset<T, Users_KhachHangDeleteArgs<ExtArgs>>): Prisma__Users_KhachHangClient<$Result.GetResult<Prisma.$Users_KhachHangPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users_KhachHang.
     * @param {Users_KhachHangUpdateArgs} args - Arguments to update one Users_KhachHang.
     * @example
     * // Update one Users_KhachHang
     * const users_KhachHang = await prisma.users_KhachHang.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Users_KhachHangUpdateArgs>(args: SelectSubset<T, Users_KhachHangUpdateArgs<ExtArgs>>): Prisma__Users_KhachHangClient<$Result.GetResult<Prisma.$Users_KhachHangPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users_KhachHangs.
     * @param {Users_KhachHangDeleteManyArgs} args - Arguments to filter Users_KhachHangs to delete.
     * @example
     * // Delete a few Users_KhachHangs
     * const { count } = await prisma.users_KhachHang.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Users_KhachHangDeleteManyArgs>(args?: SelectSubset<T, Users_KhachHangDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users_KhachHangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_KhachHangUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users_KhachHangs
     * const users_KhachHang = await prisma.users_KhachHang.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Users_KhachHangUpdateManyArgs>(args: SelectSubset<T, Users_KhachHangUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users_KhachHang.
     * @param {Users_KhachHangUpsertArgs} args - Arguments to update or create a Users_KhachHang.
     * @example
     * // Update or create a Users_KhachHang
     * const users_KhachHang = await prisma.users_KhachHang.upsert({
     *   create: {
     *     // ... data to create a Users_KhachHang
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users_KhachHang we want to update
     *   }
     * })
     */
    upsert<T extends Users_KhachHangUpsertArgs>(args: SelectSubset<T, Users_KhachHangUpsertArgs<ExtArgs>>): Prisma__Users_KhachHangClient<$Result.GetResult<Prisma.$Users_KhachHangPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Users_KhachHangs that matches the filter.
     * @param {Users_KhachHangFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const users_KhachHang = await prisma.users_KhachHang.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: Users_KhachHangFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Users_KhachHang.
     * @param {Users_KhachHangAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const users_KhachHang = await prisma.users_KhachHang.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: Users_KhachHangAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users_KhachHangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_KhachHangCountArgs} args - Arguments to filter Users_KhachHangs to count.
     * @example
     * // Count the number of Users_KhachHangs
     * const count = await prisma.users_KhachHang.count({
     *   where: {
     *     // ... the filter for the Users_KhachHangs we want to count
     *   }
     * })
    **/
    count<T extends Users_KhachHangCountArgs>(
      args?: Subset<T, Users_KhachHangCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Users_KhachHangCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users_KhachHang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_KhachHangAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Users_KhachHangAggregateArgs>(args: Subset<T, Users_KhachHangAggregateArgs>): Prisma.PrismaPromise<GetUsers_KhachHangAggregateType<T>>

    /**
     * Group by Users_KhachHang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_KhachHangGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Users_KhachHangGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Users_KhachHangGroupByArgs['orderBy'] }
        : { orderBy?: Users_KhachHangGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Users_KhachHangGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsers_KhachHangGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users_KhachHang model
   */
  readonly fields: Users_KhachHangFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users_KhachHang.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Users_KhachHangClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends Roles_KhachHangDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Roles_KhachHangDefaultArgs<ExtArgs>>): Prisma__Roles_KhachHangClient<$Result.GetResult<Prisma.$Roles_KhachHangPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users_KhachHang model
   */ 
  interface Users_KhachHangFieldRefs {
    readonly id_user_KhachHang: FieldRef<"Users_KhachHang", 'String'>
    readonly id_uk: FieldRef<"Users_KhachHang", 'String'>
    readonly user_name: FieldRef<"Users_KhachHang", 'String'>
    readonly name: FieldRef<"Users_KhachHang", 'String'>
    readonly email: FieldRef<"Users_KhachHang", 'String'>
    readonly phone: FieldRef<"Users_KhachHang", 'String'>
    readonly google_id: FieldRef<"Users_KhachHang", 'String'>
    readonly gender: FieldRef<"Users_KhachHang", 'Gender'>
    readonly date_of_birth: FieldRef<"Users_KhachHang", 'DateTime'>
    readonly avatar: FieldRef<"Users_KhachHang", 'String'>
    readonly createdAt: FieldRef<"Users_KhachHang", 'DateTime'>
    readonly updatedAt: FieldRef<"Users_KhachHang", 'DateTime'>
    readonly id_role_KhachHang: FieldRef<"Users_KhachHang", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Users_KhachHang findUnique
   */
  export type Users_KhachHangFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_KhachHang
     */
    select?: Users_KhachHangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_KhachHangInclude<ExtArgs> | null
    /**
     * Filter, which Users_KhachHang to fetch.
     */
    where: Users_KhachHangWhereUniqueInput
  }

  /**
   * Users_KhachHang findUniqueOrThrow
   */
  export type Users_KhachHangFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_KhachHang
     */
    select?: Users_KhachHangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_KhachHangInclude<ExtArgs> | null
    /**
     * Filter, which Users_KhachHang to fetch.
     */
    where: Users_KhachHangWhereUniqueInput
  }

  /**
   * Users_KhachHang findFirst
   */
  export type Users_KhachHangFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_KhachHang
     */
    select?: Users_KhachHangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_KhachHangInclude<ExtArgs> | null
    /**
     * Filter, which Users_KhachHang to fetch.
     */
    where?: Users_KhachHangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users_KhachHangs to fetch.
     */
    orderBy?: Users_KhachHangOrderByWithRelationInput | Users_KhachHangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users_KhachHangs.
     */
    cursor?: Users_KhachHangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users_KhachHangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users_KhachHangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users_KhachHangs.
     */
    distinct?: Users_KhachHangScalarFieldEnum | Users_KhachHangScalarFieldEnum[]
  }

  /**
   * Users_KhachHang findFirstOrThrow
   */
  export type Users_KhachHangFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_KhachHang
     */
    select?: Users_KhachHangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_KhachHangInclude<ExtArgs> | null
    /**
     * Filter, which Users_KhachHang to fetch.
     */
    where?: Users_KhachHangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users_KhachHangs to fetch.
     */
    orderBy?: Users_KhachHangOrderByWithRelationInput | Users_KhachHangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users_KhachHangs.
     */
    cursor?: Users_KhachHangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users_KhachHangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users_KhachHangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users_KhachHangs.
     */
    distinct?: Users_KhachHangScalarFieldEnum | Users_KhachHangScalarFieldEnum[]
  }

  /**
   * Users_KhachHang findMany
   */
  export type Users_KhachHangFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_KhachHang
     */
    select?: Users_KhachHangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_KhachHangInclude<ExtArgs> | null
    /**
     * Filter, which Users_KhachHangs to fetch.
     */
    where?: Users_KhachHangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users_KhachHangs to fetch.
     */
    orderBy?: Users_KhachHangOrderByWithRelationInput | Users_KhachHangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users_KhachHangs.
     */
    cursor?: Users_KhachHangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users_KhachHangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users_KhachHangs.
     */
    skip?: number
    distinct?: Users_KhachHangScalarFieldEnum | Users_KhachHangScalarFieldEnum[]
  }

  /**
   * Users_KhachHang create
   */
  export type Users_KhachHangCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_KhachHang
     */
    select?: Users_KhachHangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_KhachHangInclude<ExtArgs> | null
    /**
     * The data needed to create a Users_KhachHang.
     */
    data: XOR<Users_KhachHangCreateInput, Users_KhachHangUncheckedCreateInput>
  }

  /**
   * Users_KhachHang createMany
   */
  export type Users_KhachHangCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users_KhachHangs.
     */
    data: Users_KhachHangCreateManyInput | Users_KhachHangCreateManyInput[]
  }

  /**
   * Users_KhachHang update
   */
  export type Users_KhachHangUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_KhachHang
     */
    select?: Users_KhachHangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_KhachHangInclude<ExtArgs> | null
    /**
     * The data needed to update a Users_KhachHang.
     */
    data: XOR<Users_KhachHangUpdateInput, Users_KhachHangUncheckedUpdateInput>
    /**
     * Choose, which Users_KhachHang to update.
     */
    where: Users_KhachHangWhereUniqueInput
  }

  /**
   * Users_KhachHang updateMany
   */
  export type Users_KhachHangUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users_KhachHangs.
     */
    data: XOR<Users_KhachHangUpdateManyMutationInput, Users_KhachHangUncheckedUpdateManyInput>
    /**
     * Filter which Users_KhachHangs to update
     */
    where?: Users_KhachHangWhereInput
  }

  /**
   * Users_KhachHang upsert
   */
  export type Users_KhachHangUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_KhachHang
     */
    select?: Users_KhachHangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_KhachHangInclude<ExtArgs> | null
    /**
     * The filter to search for the Users_KhachHang to update in case it exists.
     */
    where: Users_KhachHangWhereUniqueInput
    /**
     * In case the Users_KhachHang found by the `where` argument doesn't exist, create a new Users_KhachHang with this data.
     */
    create: XOR<Users_KhachHangCreateInput, Users_KhachHangUncheckedCreateInput>
    /**
     * In case the Users_KhachHang was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Users_KhachHangUpdateInput, Users_KhachHangUncheckedUpdateInput>
  }

  /**
   * Users_KhachHang delete
   */
  export type Users_KhachHangDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_KhachHang
     */
    select?: Users_KhachHangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_KhachHangInclude<ExtArgs> | null
    /**
     * Filter which Users_KhachHang to delete.
     */
    where: Users_KhachHangWhereUniqueInput
  }

  /**
   * Users_KhachHang deleteMany
   */
  export type Users_KhachHangDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users_KhachHangs to delete
     */
    where?: Users_KhachHangWhereInput
  }

  /**
   * Users_KhachHang findRaw
   */
  export type Users_KhachHangFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Users_KhachHang aggregateRaw
   */
  export type Users_KhachHangAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Users_KhachHang without action
   */
  export type Users_KhachHangDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_KhachHang
     */
    select?: Users_KhachHangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_KhachHangInclude<ExtArgs> | null
  }


  /**
   * Model Users_Staff
   */

  export type AggregateUsers_Staff = {
    _count: Users_StaffCountAggregateOutputType | null
    _min: Users_StaffMinAggregateOutputType | null
    _max: Users_StaffMaxAggregateOutputType | null
  }

  export type Users_StaffMinAggregateOutputType = {
    id_user_staff: string | null
    id_ut: string | null
    user_name: string | null
    name: string | null
    email: string | null
    phone: string | null
    google_id: string | null
    gender: $Enums.Gender | null
    date_of_birth: Date | null
    avatar: string | null
    createdAt: Date | null
    updatedAt: Date | null
    id_role_staff: string | null
  }

  export type Users_StaffMaxAggregateOutputType = {
    id_user_staff: string | null
    id_ut: string | null
    user_name: string | null
    name: string | null
    email: string | null
    phone: string | null
    google_id: string | null
    gender: $Enums.Gender | null
    date_of_birth: Date | null
    avatar: string | null
    createdAt: Date | null
    updatedAt: Date | null
    id_role_staff: string | null
  }

  export type Users_StaffCountAggregateOutputType = {
    id_user_staff: number
    id_ut: number
    user_name: number
    name: number
    email: number
    phone: number
    google_id: number
    gender: number
    date_of_birth: number
    avatar: number
    createdAt: number
    updatedAt: number
    id_role_staff: number
    _all: number
  }


  export type Users_StaffMinAggregateInputType = {
    id_user_staff?: true
    id_ut?: true
    user_name?: true
    name?: true
    email?: true
    phone?: true
    google_id?: true
    gender?: true
    date_of_birth?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
    id_role_staff?: true
  }

  export type Users_StaffMaxAggregateInputType = {
    id_user_staff?: true
    id_ut?: true
    user_name?: true
    name?: true
    email?: true
    phone?: true
    google_id?: true
    gender?: true
    date_of_birth?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
    id_role_staff?: true
  }

  export type Users_StaffCountAggregateInputType = {
    id_user_staff?: true
    id_ut?: true
    user_name?: true
    name?: true
    email?: true
    phone?: true
    google_id?: true
    gender?: true
    date_of_birth?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
    id_role_staff?: true
    _all?: true
  }

  export type Users_StaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users_Staff to aggregate.
     */
    where?: Users_StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users_Staffs to fetch.
     */
    orderBy?: Users_StaffOrderByWithRelationInput | Users_StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Users_StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users_Staffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users_Staffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users_Staffs
    **/
    _count?: true | Users_StaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Users_StaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Users_StaffMaxAggregateInputType
  }

  export type GetUsers_StaffAggregateType<T extends Users_StaffAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers_Staff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers_Staff[P]>
      : GetScalarType<T[P], AggregateUsers_Staff[P]>
  }




  export type Users_StaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Users_StaffWhereInput
    orderBy?: Users_StaffOrderByWithAggregationInput | Users_StaffOrderByWithAggregationInput[]
    by: Users_StaffScalarFieldEnum[] | Users_StaffScalarFieldEnum
    having?: Users_StaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Users_StaffCountAggregateInputType | true
    _min?: Users_StaffMinAggregateInputType
    _max?: Users_StaffMaxAggregateInputType
  }

  export type Users_StaffGroupByOutputType = {
    id_user_staff: string
    id_ut: string
    user_name: string
    name: string | null
    email: string
    phone: string | null
    google_id: string | null
    gender: $Enums.Gender
    date_of_birth: Date
    avatar: string | null
    createdAt: Date
    updatedAt: Date
    id_role_staff: string
    _count: Users_StaffCountAggregateOutputType | null
    _min: Users_StaffMinAggregateOutputType | null
    _max: Users_StaffMaxAggregateOutputType | null
  }

  type GetUsers_StaffGroupByPayload<T extends Users_StaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Users_StaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Users_StaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Users_StaffGroupByOutputType[P]>
            : GetScalarType<T[P], Users_StaffGroupByOutputType[P]>
        }
      >
    >


  export type Users_StaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_user_staff?: boolean
    id_ut?: boolean
    user_name?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    google_id?: boolean
    gender?: boolean
    date_of_birth?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id_role_staff?: boolean
    role?: boolean | Roles_StaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users_Staff"]>


  export type Users_StaffSelectScalar = {
    id_user_staff?: boolean
    id_ut?: boolean
    user_name?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    google_id?: boolean
    gender?: boolean
    date_of_birth?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id_role_staff?: boolean
  }

  export type Users_StaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | Roles_StaffDefaultArgs<ExtArgs>
  }

  export type $Users_StaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users_Staff"
    objects: {
      role: Prisma.$Roles_StaffPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_user_staff: string
      id_ut: string
      user_name: string
      name: string | null
      email: string
      phone: string | null
      google_id: string | null
      gender: $Enums.Gender
      date_of_birth: Date
      avatar: string | null
      createdAt: Date
      updatedAt: Date
      id_role_staff: string
    }, ExtArgs["result"]["users_Staff"]>
    composites: {}
  }

  type Users_StaffGetPayload<S extends boolean | null | undefined | Users_StaffDefaultArgs> = $Result.GetResult<Prisma.$Users_StaffPayload, S>

  type Users_StaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Users_StaffFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Users_StaffCountAggregateInputType | true
    }

  export interface Users_StaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users_Staff'], meta: { name: 'Users_Staff' } }
    /**
     * Find zero or one Users_Staff that matches the filter.
     * @param {Users_StaffFindUniqueArgs} args - Arguments to find a Users_Staff
     * @example
     * // Get one Users_Staff
     * const users_Staff = await prisma.users_Staff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Users_StaffFindUniqueArgs>(args: SelectSubset<T, Users_StaffFindUniqueArgs<ExtArgs>>): Prisma__Users_StaffClient<$Result.GetResult<Prisma.$Users_StaffPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users_Staff that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Users_StaffFindUniqueOrThrowArgs} args - Arguments to find a Users_Staff
     * @example
     * // Get one Users_Staff
     * const users_Staff = await prisma.users_Staff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Users_StaffFindUniqueOrThrowArgs>(args: SelectSubset<T, Users_StaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Users_StaffClient<$Result.GetResult<Prisma.$Users_StaffPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users_Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_StaffFindFirstArgs} args - Arguments to find a Users_Staff
     * @example
     * // Get one Users_Staff
     * const users_Staff = await prisma.users_Staff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Users_StaffFindFirstArgs>(args?: SelectSubset<T, Users_StaffFindFirstArgs<ExtArgs>>): Prisma__Users_StaffClient<$Result.GetResult<Prisma.$Users_StaffPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users_Staff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_StaffFindFirstOrThrowArgs} args - Arguments to find a Users_Staff
     * @example
     * // Get one Users_Staff
     * const users_Staff = await prisma.users_Staff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Users_StaffFindFirstOrThrowArgs>(args?: SelectSubset<T, Users_StaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__Users_StaffClient<$Result.GetResult<Prisma.$Users_StaffPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users_Staffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_StaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users_Staffs
     * const users_Staffs = await prisma.users_Staff.findMany()
     * 
     * // Get first 10 Users_Staffs
     * const users_Staffs = await prisma.users_Staff.findMany({ take: 10 })
     * 
     * // Only select the `id_user_staff`
     * const users_StaffWithId_user_staffOnly = await prisma.users_Staff.findMany({ select: { id_user_staff: true } })
     * 
     */
    findMany<T extends Users_StaffFindManyArgs>(args?: SelectSubset<T, Users_StaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Users_StaffPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users_Staff.
     * @param {Users_StaffCreateArgs} args - Arguments to create a Users_Staff.
     * @example
     * // Create one Users_Staff
     * const Users_Staff = await prisma.users_Staff.create({
     *   data: {
     *     // ... data to create a Users_Staff
     *   }
     * })
     * 
     */
    create<T extends Users_StaffCreateArgs>(args: SelectSubset<T, Users_StaffCreateArgs<ExtArgs>>): Prisma__Users_StaffClient<$Result.GetResult<Prisma.$Users_StaffPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users_Staffs.
     * @param {Users_StaffCreateManyArgs} args - Arguments to create many Users_Staffs.
     * @example
     * // Create many Users_Staffs
     * const users_Staff = await prisma.users_Staff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Users_StaffCreateManyArgs>(args?: SelectSubset<T, Users_StaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users_Staff.
     * @param {Users_StaffDeleteArgs} args - Arguments to delete one Users_Staff.
     * @example
     * // Delete one Users_Staff
     * const Users_Staff = await prisma.users_Staff.delete({
     *   where: {
     *     // ... filter to delete one Users_Staff
     *   }
     * })
     * 
     */
    delete<T extends Users_StaffDeleteArgs>(args: SelectSubset<T, Users_StaffDeleteArgs<ExtArgs>>): Prisma__Users_StaffClient<$Result.GetResult<Prisma.$Users_StaffPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users_Staff.
     * @param {Users_StaffUpdateArgs} args - Arguments to update one Users_Staff.
     * @example
     * // Update one Users_Staff
     * const users_Staff = await prisma.users_Staff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Users_StaffUpdateArgs>(args: SelectSubset<T, Users_StaffUpdateArgs<ExtArgs>>): Prisma__Users_StaffClient<$Result.GetResult<Prisma.$Users_StaffPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users_Staffs.
     * @param {Users_StaffDeleteManyArgs} args - Arguments to filter Users_Staffs to delete.
     * @example
     * // Delete a few Users_Staffs
     * const { count } = await prisma.users_Staff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Users_StaffDeleteManyArgs>(args?: SelectSubset<T, Users_StaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users_Staffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_StaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users_Staffs
     * const users_Staff = await prisma.users_Staff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Users_StaffUpdateManyArgs>(args: SelectSubset<T, Users_StaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users_Staff.
     * @param {Users_StaffUpsertArgs} args - Arguments to update or create a Users_Staff.
     * @example
     * // Update or create a Users_Staff
     * const users_Staff = await prisma.users_Staff.upsert({
     *   create: {
     *     // ... data to create a Users_Staff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users_Staff we want to update
     *   }
     * })
     */
    upsert<T extends Users_StaffUpsertArgs>(args: SelectSubset<T, Users_StaffUpsertArgs<ExtArgs>>): Prisma__Users_StaffClient<$Result.GetResult<Prisma.$Users_StaffPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Users_Staffs that matches the filter.
     * @param {Users_StaffFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const users_Staff = await prisma.users_Staff.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: Users_StaffFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Users_Staff.
     * @param {Users_StaffAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const users_Staff = await prisma.users_Staff.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: Users_StaffAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users_Staffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_StaffCountArgs} args - Arguments to filter Users_Staffs to count.
     * @example
     * // Count the number of Users_Staffs
     * const count = await prisma.users_Staff.count({
     *   where: {
     *     // ... the filter for the Users_Staffs we want to count
     *   }
     * })
    **/
    count<T extends Users_StaffCountArgs>(
      args?: Subset<T, Users_StaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Users_StaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users_Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_StaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Users_StaffAggregateArgs>(args: Subset<T, Users_StaffAggregateArgs>): Prisma.PrismaPromise<GetUsers_StaffAggregateType<T>>

    /**
     * Group by Users_Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_StaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Users_StaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Users_StaffGroupByArgs['orderBy'] }
        : { orderBy?: Users_StaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Users_StaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsers_StaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users_Staff model
   */
  readonly fields: Users_StaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users_Staff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Users_StaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends Roles_StaffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Roles_StaffDefaultArgs<ExtArgs>>): Prisma__Roles_StaffClient<$Result.GetResult<Prisma.$Roles_StaffPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users_Staff model
   */ 
  interface Users_StaffFieldRefs {
    readonly id_user_staff: FieldRef<"Users_Staff", 'String'>
    readonly id_ut: FieldRef<"Users_Staff", 'String'>
    readonly user_name: FieldRef<"Users_Staff", 'String'>
    readonly name: FieldRef<"Users_Staff", 'String'>
    readonly email: FieldRef<"Users_Staff", 'String'>
    readonly phone: FieldRef<"Users_Staff", 'String'>
    readonly google_id: FieldRef<"Users_Staff", 'String'>
    readonly gender: FieldRef<"Users_Staff", 'Gender'>
    readonly date_of_birth: FieldRef<"Users_Staff", 'DateTime'>
    readonly avatar: FieldRef<"Users_Staff", 'String'>
    readonly createdAt: FieldRef<"Users_Staff", 'DateTime'>
    readonly updatedAt: FieldRef<"Users_Staff", 'DateTime'>
    readonly id_role_staff: FieldRef<"Users_Staff", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Users_Staff findUnique
   */
  export type Users_StaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_Staff
     */
    select?: Users_StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_StaffInclude<ExtArgs> | null
    /**
     * Filter, which Users_Staff to fetch.
     */
    where: Users_StaffWhereUniqueInput
  }

  /**
   * Users_Staff findUniqueOrThrow
   */
  export type Users_StaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_Staff
     */
    select?: Users_StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_StaffInclude<ExtArgs> | null
    /**
     * Filter, which Users_Staff to fetch.
     */
    where: Users_StaffWhereUniqueInput
  }

  /**
   * Users_Staff findFirst
   */
  export type Users_StaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_Staff
     */
    select?: Users_StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_StaffInclude<ExtArgs> | null
    /**
     * Filter, which Users_Staff to fetch.
     */
    where?: Users_StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users_Staffs to fetch.
     */
    orderBy?: Users_StaffOrderByWithRelationInput | Users_StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users_Staffs.
     */
    cursor?: Users_StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users_Staffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users_Staffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users_Staffs.
     */
    distinct?: Users_StaffScalarFieldEnum | Users_StaffScalarFieldEnum[]
  }

  /**
   * Users_Staff findFirstOrThrow
   */
  export type Users_StaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_Staff
     */
    select?: Users_StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_StaffInclude<ExtArgs> | null
    /**
     * Filter, which Users_Staff to fetch.
     */
    where?: Users_StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users_Staffs to fetch.
     */
    orderBy?: Users_StaffOrderByWithRelationInput | Users_StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users_Staffs.
     */
    cursor?: Users_StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users_Staffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users_Staffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users_Staffs.
     */
    distinct?: Users_StaffScalarFieldEnum | Users_StaffScalarFieldEnum[]
  }

  /**
   * Users_Staff findMany
   */
  export type Users_StaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_Staff
     */
    select?: Users_StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_StaffInclude<ExtArgs> | null
    /**
     * Filter, which Users_Staffs to fetch.
     */
    where?: Users_StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users_Staffs to fetch.
     */
    orderBy?: Users_StaffOrderByWithRelationInput | Users_StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users_Staffs.
     */
    cursor?: Users_StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users_Staffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users_Staffs.
     */
    skip?: number
    distinct?: Users_StaffScalarFieldEnum | Users_StaffScalarFieldEnum[]
  }

  /**
   * Users_Staff create
   */
  export type Users_StaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_Staff
     */
    select?: Users_StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_StaffInclude<ExtArgs> | null
    /**
     * The data needed to create a Users_Staff.
     */
    data: XOR<Users_StaffCreateInput, Users_StaffUncheckedCreateInput>
  }

  /**
   * Users_Staff createMany
   */
  export type Users_StaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users_Staffs.
     */
    data: Users_StaffCreateManyInput | Users_StaffCreateManyInput[]
  }

  /**
   * Users_Staff update
   */
  export type Users_StaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_Staff
     */
    select?: Users_StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_StaffInclude<ExtArgs> | null
    /**
     * The data needed to update a Users_Staff.
     */
    data: XOR<Users_StaffUpdateInput, Users_StaffUncheckedUpdateInput>
    /**
     * Choose, which Users_Staff to update.
     */
    where: Users_StaffWhereUniqueInput
  }

  /**
   * Users_Staff updateMany
   */
  export type Users_StaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users_Staffs.
     */
    data: XOR<Users_StaffUpdateManyMutationInput, Users_StaffUncheckedUpdateManyInput>
    /**
     * Filter which Users_Staffs to update
     */
    where?: Users_StaffWhereInput
  }

  /**
   * Users_Staff upsert
   */
  export type Users_StaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_Staff
     */
    select?: Users_StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_StaffInclude<ExtArgs> | null
    /**
     * The filter to search for the Users_Staff to update in case it exists.
     */
    where: Users_StaffWhereUniqueInput
    /**
     * In case the Users_Staff found by the `where` argument doesn't exist, create a new Users_Staff with this data.
     */
    create: XOR<Users_StaffCreateInput, Users_StaffUncheckedCreateInput>
    /**
     * In case the Users_Staff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Users_StaffUpdateInput, Users_StaffUncheckedUpdateInput>
  }

  /**
   * Users_Staff delete
   */
  export type Users_StaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_Staff
     */
    select?: Users_StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_StaffInclude<ExtArgs> | null
    /**
     * Filter which Users_Staff to delete.
     */
    where: Users_StaffWhereUniqueInput
  }

  /**
   * Users_Staff deleteMany
   */
  export type Users_StaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users_Staffs to delete
     */
    where?: Users_StaffWhereInput
  }

  /**
   * Users_Staff findRaw
   */
  export type Users_StaffFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Users_Staff aggregateRaw
   */
  export type Users_StaffAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Users_Staff without action
   */
  export type Users_StaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_Staff
     */
    select?: Users_StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Users_StaffInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const BrandsScalarFieldEnum: {
    id_brand: 'id_brand',
    id_b: 'id_b',
    name: 'name',
    description: 'description',
    logo: 'logo',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BrandsScalarFieldEnum = (typeof BrandsScalarFieldEnum)[keyof typeof BrandsScalarFieldEnum]


  export const Owners_BrandScalarFieldEnum: {
    id_owners_brand: 'id_owners_brand',
    id_brand: 'id_brand',
    id_user_admin: 'id_user_admin',
    createdAt: 'createdAt'
  };

  export type Owners_BrandScalarFieldEnum = (typeof Owners_BrandScalarFieldEnum)[keyof typeof Owners_BrandScalarFieldEnum]


  export const Roles_AdminScalarFieldEnum: {
    id_role_admin: 'id_role_admin',
    id_ra: 'id_ra',
    name: 'name',
    description: 'description'
  };

  export type Roles_AdminScalarFieldEnum = (typeof Roles_AdminScalarFieldEnum)[keyof typeof Roles_AdminScalarFieldEnum]


  export const Roles_KhachHangScalarFieldEnum: {
    id_role_KhachHang: 'id_role_KhachHang',
    id_rkh: 'id_rkh',
    name: 'name',
    description: 'description'
  };

  export type Roles_KhachHangScalarFieldEnum = (typeof Roles_KhachHangScalarFieldEnum)[keyof typeof Roles_KhachHangScalarFieldEnum]


  export const Roles_StaffScalarFieldEnum: {
    id_role_staff: 'id_role_staff',
    id_rt: 'id_rt',
    name: 'name',
    description: 'description'
  };

  export type Roles_StaffScalarFieldEnum = (typeof Roles_StaffScalarFieldEnum)[keyof typeof Roles_StaffScalarFieldEnum]


  export const Users_AdminScalarFieldEnum: {
    id_user_admin: 'id_user_admin',
    id_ud: 'id_ud',
    user_name: 'user_name',
    name: 'name',
    email: 'email',
    phone: 'phone',
    password_hash: 'password_hash',
    google_id: 'google_id',
    gender: 'gender',
    date_of_birth: 'date_of_birth',
    avatar: 'avatar',
    id_role_admin: 'id_role_admin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Users_AdminScalarFieldEnum = (typeof Users_AdminScalarFieldEnum)[keyof typeof Users_AdminScalarFieldEnum]


  export const Users_KhachHangScalarFieldEnum: {
    id_user_KhachHang: 'id_user_KhachHang',
    id_uk: 'id_uk',
    user_name: 'user_name',
    name: 'name',
    email: 'email',
    phone: 'phone',
    google_id: 'google_id',
    gender: 'gender',
    date_of_birth: 'date_of_birth',
    avatar: 'avatar',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id_role_KhachHang: 'id_role_KhachHang'
  };

  export type Users_KhachHangScalarFieldEnum = (typeof Users_KhachHangScalarFieldEnum)[keyof typeof Users_KhachHangScalarFieldEnum]


  export const Users_StaffScalarFieldEnum: {
    id_user_staff: 'id_user_staff',
    id_ut: 'id_ut',
    user_name: 'user_name',
    name: 'name',
    email: 'email',
    phone: 'phone',
    google_id: 'google_id',
    gender: 'gender',
    date_of_birth: 'date_of_birth',
    avatar: 'avatar',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id_role_staff: 'id_role_staff'
  };

  export type Users_StaffScalarFieldEnum = (typeof Users_StaffScalarFieldEnum)[keyof typeof Users_StaffScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Status_Brand'
   */
  export type EnumStatus_BrandFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status_Brand'>
    


  /**
   * Reference to a field of type 'Status_Brand[]'
   */
  export type ListEnumStatus_BrandFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status_Brand[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type BrandsWhereInput = {
    AND?: BrandsWhereInput | BrandsWhereInput[]
    OR?: BrandsWhereInput[]
    NOT?: BrandsWhereInput | BrandsWhereInput[]
    id_brand?: StringFilter<"Brands"> | string
    id_b?: StringFilter<"Brands"> | string
    name?: StringFilter<"Brands"> | string
    description?: StringNullableFilter<"Brands"> | string | null
    logo?: StringNullableFilter<"Brands"> | string | null
    status?: EnumStatus_BrandFilter<"Brands"> | $Enums.Status_Brand
    createdAt?: DateTimeFilter<"Brands"> | Date | string
    updatedAt?: DateTimeFilter<"Brands"> | Date | string
    owners_brand?: Owners_BrandListRelationFilter
  }

  export type BrandsOrderByWithRelationInput = {
    id_brand?: SortOrder
    id_b?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owners_brand?: Owners_BrandOrderByRelationAggregateInput
  }

  export type BrandsWhereUniqueInput = Prisma.AtLeast<{
    id_brand?: string
    id_b?: string
    name?: string
    AND?: BrandsWhereInput | BrandsWhereInput[]
    OR?: BrandsWhereInput[]
    NOT?: BrandsWhereInput | BrandsWhereInput[]
    description?: StringNullableFilter<"Brands"> | string | null
    logo?: StringNullableFilter<"Brands"> | string | null
    status?: EnumStatus_BrandFilter<"Brands"> | $Enums.Status_Brand
    createdAt?: DateTimeFilter<"Brands"> | Date | string
    updatedAt?: DateTimeFilter<"Brands"> | Date | string
    owners_brand?: Owners_BrandListRelationFilter
  }, "id_brand" | "id_b" | "name">

  export type BrandsOrderByWithAggregationInput = {
    id_brand?: SortOrder
    id_b?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BrandsCountOrderByAggregateInput
    _max?: BrandsMaxOrderByAggregateInput
    _min?: BrandsMinOrderByAggregateInput
  }

  export type BrandsScalarWhereWithAggregatesInput = {
    AND?: BrandsScalarWhereWithAggregatesInput | BrandsScalarWhereWithAggregatesInput[]
    OR?: BrandsScalarWhereWithAggregatesInput[]
    NOT?: BrandsScalarWhereWithAggregatesInput | BrandsScalarWhereWithAggregatesInput[]
    id_brand?: StringWithAggregatesFilter<"Brands"> | string
    id_b?: StringWithAggregatesFilter<"Brands"> | string
    name?: StringWithAggregatesFilter<"Brands"> | string
    description?: StringNullableWithAggregatesFilter<"Brands"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Brands"> | string | null
    status?: EnumStatus_BrandWithAggregatesFilter<"Brands"> | $Enums.Status_Brand
    createdAt?: DateTimeWithAggregatesFilter<"Brands"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Brands"> | Date | string
  }

  export type Owners_BrandWhereInput = {
    AND?: Owners_BrandWhereInput | Owners_BrandWhereInput[]
    OR?: Owners_BrandWhereInput[]
    NOT?: Owners_BrandWhereInput | Owners_BrandWhereInput[]
    id_owners_brand?: StringFilter<"Owners_Brand"> | string
    id_brand?: StringFilter<"Owners_Brand"> | string
    id_user_admin?: StringFilter<"Owners_Brand"> | string
    createdAt?: DateTimeFilter<"Owners_Brand"> | Date | string
    user_admin?: XOR<Users_AdminRelationFilter, Users_AdminWhereInput>
    brand?: XOR<BrandsRelationFilter, BrandsWhereInput>
  }

  export type Owners_BrandOrderByWithRelationInput = {
    id_owners_brand?: SortOrder
    id_brand?: SortOrder
    id_user_admin?: SortOrder
    createdAt?: SortOrder
    user_admin?: Users_AdminOrderByWithRelationInput
    brand?: BrandsOrderByWithRelationInput
  }

  export type Owners_BrandWhereUniqueInput = Prisma.AtLeast<{
    id_owners_brand?: string
    AND?: Owners_BrandWhereInput | Owners_BrandWhereInput[]
    OR?: Owners_BrandWhereInput[]
    NOT?: Owners_BrandWhereInput | Owners_BrandWhereInput[]
    id_brand?: StringFilter<"Owners_Brand"> | string
    id_user_admin?: StringFilter<"Owners_Brand"> | string
    createdAt?: DateTimeFilter<"Owners_Brand"> | Date | string
    user_admin?: XOR<Users_AdminRelationFilter, Users_AdminWhereInput>
    brand?: XOR<BrandsRelationFilter, BrandsWhereInput>
  }, "id_owners_brand">

  export type Owners_BrandOrderByWithAggregationInput = {
    id_owners_brand?: SortOrder
    id_brand?: SortOrder
    id_user_admin?: SortOrder
    createdAt?: SortOrder
    _count?: Owners_BrandCountOrderByAggregateInput
    _max?: Owners_BrandMaxOrderByAggregateInput
    _min?: Owners_BrandMinOrderByAggregateInput
  }

  export type Owners_BrandScalarWhereWithAggregatesInput = {
    AND?: Owners_BrandScalarWhereWithAggregatesInput | Owners_BrandScalarWhereWithAggregatesInput[]
    OR?: Owners_BrandScalarWhereWithAggregatesInput[]
    NOT?: Owners_BrandScalarWhereWithAggregatesInput | Owners_BrandScalarWhereWithAggregatesInput[]
    id_owners_brand?: StringWithAggregatesFilter<"Owners_Brand"> | string
    id_brand?: StringWithAggregatesFilter<"Owners_Brand"> | string
    id_user_admin?: StringWithAggregatesFilter<"Owners_Brand"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Owners_Brand"> | Date | string
  }

  export type Roles_AdminWhereInput = {
    AND?: Roles_AdminWhereInput | Roles_AdminWhereInput[]
    OR?: Roles_AdminWhereInput[]
    NOT?: Roles_AdminWhereInput | Roles_AdminWhereInput[]
    id_role_admin?: StringFilter<"Roles_Admin"> | string
    id_ra?: StringFilter<"Roles_Admin"> | string
    name?: StringFilter<"Roles_Admin"> | string
    description?: StringNullableFilter<"Roles_Admin"> | string | null
    users_admin?: Users_AdminListRelationFilter
  }

  export type Roles_AdminOrderByWithRelationInput = {
    id_role_admin?: SortOrder
    id_ra?: SortOrder
    name?: SortOrder
    description?: SortOrder
    users_admin?: Users_AdminOrderByRelationAggregateInput
  }

  export type Roles_AdminWhereUniqueInput = Prisma.AtLeast<{
    id_role_admin?: string
    id_ra?: string
    name?: string
    AND?: Roles_AdminWhereInput | Roles_AdminWhereInput[]
    OR?: Roles_AdminWhereInput[]
    NOT?: Roles_AdminWhereInput | Roles_AdminWhereInput[]
    description?: StringNullableFilter<"Roles_Admin"> | string | null
    users_admin?: Users_AdminListRelationFilter
  }, "id_role_admin" | "id_ra" | "name">

  export type Roles_AdminOrderByWithAggregationInput = {
    id_role_admin?: SortOrder
    id_ra?: SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: Roles_AdminCountOrderByAggregateInput
    _max?: Roles_AdminMaxOrderByAggregateInput
    _min?: Roles_AdminMinOrderByAggregateInput
  }

  export type Roles_AdminScalarWhereWithAggregatesInput = {
    AND?: Roles_AdminScalarWhereWithAggregatesInput | Roles_AdminScalarWhereWithAggregatesInput[]
    OR?: Roles_AdminScalarWhereWithAggregatesInput[]
    NOT?: Roles_AdminScalarWhereWithAggregatesInput | Roles_AdminScalarWhereWithAggregatesInput[]
    id_role_admin?: StringWithAggregatesFilter<"Roles_Admin"> | string
    id_ra?: StringWithAggregatesFilter<"Roles_Admin"> | string
    name?: StringWithAggregatesFilter<"Roles_Admin"> | string
    description?: StringNullableWithAggregatesFilter<"Roles_Admin"> | string | null
  }

  export type Roles_KhachHangWhereInput = {
    AND?: Roles_KhachHangWhereInput | Roles_KhachHangWhereInput[]
    OR?: Roles_KhachHangWhereInput[]
    NOT?: Roles_KhachHangWhereInput | Roles_KhachHangWhereInput[]
    id_role_KhachHang?: StringFilter<"Roles_KhachHang"> | string
    id_rkh?: StringFilter<"Roles_KhachHang"> | string
    name?: StringFilter<"Roles_KhachHang"> | string
    description?: StringNullableFilter<"Roles_KhachHang"> | string | null
    users_khachhang?: Users_KhachHangListRelationFilter
  }

  export type Roles_KhachHangOrderByWithRelationInput = {
    id_role_KhachHang?: SortOrder
    id_rkh?: SortOrder
    name?: SortOrder
    description?: SortOrder
    users_khachhang?: Users_KhachHangOrderByRelationAggregateInput
  }

  export type Roles_KhachHangWhereUniqueInput = Prisma.AtLeast<{
    id_role_KhachHang?: string
    id_rkh?: string
    name?: string
    AND?: Roles_KhachHangWhereInput | Roles_KhachHangWhereInput[]
    OR?: Roles_KhachHangWhereInput[]
    NOT?: Roles_KhachHangWhereInput | Roles_KhachHangWhereInput[]
    description?: StringNullableFilter<"Roles_KhachHang"> | string | null
    users_khachhang?: Users_KhachHangListRelationFilter
  }, "id_role_KhachHang" | "id_rkh" | "name">

  export type Roles_KhachHangOrderByWithAggregationInput = {
    id_role_KhachHang?: SortOrder
    id_rkh?: SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: Roles_KhachHangCountOrderByAggregateInput
    _max?: Roles_KhachHangMaxOrderByAggregateInput
    _min?: Roles_KhachHangMinOrderByAggregateInput
  }

  export type Roles_KhachHangScalarWhereWithAggregatesInput = {
    AND?: Roles_KhachHangScalarWhereWithAggregatesInput | Roles_KhachHangScalarWhereWithAggregatesInput[]
    OR?: Roles_KhachHangScalarWhereWithAggregatesInput[]
    NOT?: Roles_KhachHangScalarWhereWithAggregatesInput | Roles_KhachHangScalarWhereWithAggregatesInput[]
    id_role_KhachHang?: StringWithAggregatesFilter<"Roles_KhachHang"> | string
    id_rkh?: StringWithAggregatesFilter<"Roles_KhachHang"> | string
    name?: StringWithAggregatesFilter<"Roles_KhachHang"> | string
    description?: StringNullableWithAggregatesFilter<"Roles_KhachHang"> | string | null
  }

  export type Roles_StaffWhereInput = {
    AND?: Roles_StaffWhereInput | Roles_StaffWhereInput[]
    OR?: Roles_StaffWhereInput[]
    NOT?: Roles_StaffWhereInput | Roles_StaffWhereInput[]
    id_role_staff?: StringFilter<"Roles_Staff"> | string
    id_rt?: StringFilter<"Roles_Staff"> | string
    name?: StringFilter<"Roles_Staff"> | string
    description?: StringNullableFilter<"Roles_Staff"> | string | null
    users_staff?: Users_StaffListRelationFilter
  }

  export type Roles_StaffOrderByWithRelationInput = {
    id_role_staff?: SortOrder
    id_rt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    users_staff?: Users_StaffOrderByRelationAggregateInput
  }

  export type Roles_StaffWhereUniqueInput = Prisma.AtLeast<{
    id_role_staff?: string
    id_rt?: string
    name?: string
    AND?: Roles_StaffWhereInput | Roles_StaffWhereInput[]
    OR?: Roles_StaffWhereInput[]
    NOT?: Roles_StaffWhereInput | Roles_StaffWhereInput[]
    description?: StringNullableFilter<"Roles_Staff"> | string | null
    users_staff?: Users_StaffListRelationFilter
  }, "id_role_staff" | "id_rt" | "name">

  export type Roles_StaffOrderByWithAggregationInput = {
    id_role_staff?: SortOrder
    id_rt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: Roles_StaffCountOrderByAggregateInput
    _max?: Roles_StaffMaxOrderByAggregateInput
    _min?: Roles_StaffMinOrderByAggregateInput
  }

  export type Roles_StaffScalarWhereWithAggregatesInput = {
    AND?: Roles_StaffScalarWhereWithAggregatesInput | Roles_StaffScalarWhereWithAggregatesInput[]
    OR?: Roles_StaffScalarWhereWithAggregatesInput[]
    NOT?: Roles_StaffScalarWhereWithAggregatesInput | Roles_StaffScalarWhereWithAggregatesInput[]
    id_role_staff?: StringWithAggregatesFilter<"Roles_Staff"> | string
    id_rt?: StringWithAggregatesFilter<"Roles_Staff"> | string
    name?: StringWithAggregatesFilter<"Roles_Staff"> | string
    description?: StringNullableWithAggregatesFilter<"Roles_Staff"> | string | null
  }

  export type Users_AdminWhereInput = {
    AND?: Users_AdminWhereInput | Users_AdminWhereInput[]
    OR?: Users_AdminWhereInput[]
    NOT?: Users_AdminWhereInput | Users_AdminWhereInput[]
    id_user_admin?: StringFilter<"Users_Admin"> | string
    id_ud?: StringFilter<"Users_Admin"> | string
    user_name?: StringFilter<"Users_Admin"> | string
    name?: StringNullableFilter<"Users_Admin"> | string | null
    email?: StringFilter<"Users_Admin"> | string
    phone?: StringNullableFilter<"Users_Admin"> | string | null
    password_hash?: StringFilter<"Users_Admin"> | string
    google_id?: StringNullableFilter<"Users_Admin"> | string | null
    gender?: EnumGenderFilter<"Users_Admin"> | $Enums.Gender
    date_of_birth?: DateTimeFilter<"Users_Admin"> | Date | string
    avatar?: StringNullableFilter<"Users_Admin"> | string | null
    id_role_admin?: StringFilter<"Users_Admin"> | string
    createdAt?: DateTimeFilter<"Users_Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Users_Admin"> | Date | string
    role?: XOR<Roles_AdminRelationFilter, Roles_AdminWhereInput>
    owners_brand?: Owners_BrandListRelationFilter
  }

  export type Users_AdminOrderByWithRelationInput = {
    id_user_admin?: SortOrder
    id_ud?: SortOrder
    user_name?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password_hash?: SortOrder
    google_id?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    avatar?: SortOrder
    id_role_admin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: Roles_AdminOrderByWithRelationInput
    owners_brand?: Owners_BrandOrderByRelationAggregateInput
  }

  export type Users_AdminWhereUniqueInput = Prisma.AtLeast<{
    id_user_admin?: string
    id_ud?: string
    user_name?: string
    email?: string
    AND?: Users_AdminWhereInput | Users_AdminWhereInput[]
    OR?: Users_AdminWhereInput[]
    NOT?: Users_AdminWhereInput | Users_AdminWhereInput[]
    name?: StringNullableFilter<"Users_Admin"> | string | null
    phone?: StringNullableFilter<"Users_Admin"> | string | null
    password_hash?: StringFilter<"Users_Admin"> | string
    google_id?: StringNullableFilter<"Users_Admin"> | string | null
    gender?: EnumGenderFilter<"Users_Admin"> | $Enums.Gender
    date_of_birth?: DateTimeFilter<"Users_Admin"> | Date | string
    avatar?: StringNullableFilter<"Users_Admin"> | string | null
    id_role_admin?: StringFilter<"Users_Admin"> | string
    createdAt?: DateTimeFilter<"Users_Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Users_Admin"> | Date | string
    role?: XOR<Roles_AdminRelationFilter, Roles_AdminWhereInput>
    owners_brand?: Owners_BrandListRelationFilter
  }, "id_user_admin" | "id_ud" | "user_name" | "email">

  export type Users_AdminOrderByWithAggregationInput = {
    id_user_admin?: SortOrder
    id_ud?: SortOrder
    user_name?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password_hash?: SortOrder
    google_id?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    avatar?: SortOrder
    id_role_admin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: Users_AdminCountOrderByAggregateInput
    _max?: Users_AdminMaxOrderByAggregateInput
    _min?: Users_AdminMinOrderByAggregateInput
  }

  export type Users_AdminScalarWhereWithAggregatesInput = {
    AND?: Users_AdminScalarWhereWithAggregatesInput | Users_AdminScalarWhereWithAggregatesInput[]
    OR?: Users_AdminScalarWhereWithAggregatesInput[]
    NOT?: Users_AdminScalarWhereWithAggregatesInput | Users_AdminScalarWhereWithAggregatesInput[]
    id_user_admin?: StringWithAggregatesFilter<"Users_Admin"> | string
    id_ud?: StringWithAggregatesFilter<"Users_Admin"> | string
    user_name?: StringWithAggregatesFilter<"Users_Admin"> | string
    name?: StringNullableWithAggregatesFilter<"Users_Admin"> | string | null
    email?: StringWithAggregatesFilter<"Users_Admin"> | string
    phone?: StringNullableWithAggregatesFilter<"Users_Admin"> | string | null
    password_hash?: StringWithAggregatesFilter<"Users_Admin"> | string
    google_id?: StringNullableWithAggregatesFilter<"Users_Admin"> | string | null
    gender?: EnumGenderWithAggregatesFilter<"Users_Admin"> | $Enums.Gender
    date_of_birth?: DateTimeWithAggregatesFilter<"Users_Admin"> | Date | string
    avatar?: StringNullableWithAggregatesFilter<"Users_Admin"> | string | null
    id_role_admin?: StringWithAggregatesFilter<"Users_Admin"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Users_Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Users_Admin"> | Date | string
  }

  export type Users_KhachHangWhereInput = {
    AND?: Users_KhachHangWhereInput | Users_KhachHangWhereInput[]
    OR?: Users_KhachHangWhereInput[]
    NOT?: Users_KhachHangWhereInput | Users_KhachHangWhereInput[]
    id_user_KhachHang?: StringFilter<"Users_KhachHang"> | string
    id_uk?: StringFilter<"Users_KhachHang"> | string
    user_name?: StringFilter<"Users_KhachHang"> | string
    name?: StringNullableFilter<"Users_KhachHang"> | string | null
    email?: StringFilter<"Users_KhachHang"> | string
    phone?: StringNullableFilter<"Users_KhachHang"> | string | null
    google_id?: StringNullableFilter<"Users_KhachHang"> | string | null
    gender?: EnumGenderFilter<"Users_KhachHang"> | $Enums.Gender
    date_of_birth?: DateTimeFilter<"Users_KhachHang"> | Date | string
    avatar?: StringNullableFilter<"Users_KhachHang"> | string | null
    createdAt?: DateTimeFilter<"Users_KhachHang"> | Date | string
    updatedAt?: DateTimeFilter<"Users_KhachHang"> | Date | string
    id_role_KhachHang?: StringFilter<"Users_KhachHang"> | string
    role?: XOR<Roles_KhachHangRelationFilter, Roles_KhachHangWhereInput>
  }

  export type Users_KhachHangOrderByWithRelationInput = {
    id_user_KhachHang?: SortOrder
    id_uk?: SortOrder
    user_name?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    google_id?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id_role_KhachHang?: SortOrder
    role?: Roles_KhachHangOrderByWithRelationInput
  }

  export type Users_KhachHangWhereUniqueInput = Prisma.AtLeast<{
    id_user_KhachHang?: string
    id_uk?: string
    user_name?: string
    email?: string
    AND?: Users_KhachHangWhereInput | Users_KhachHangWhereInput[]
    OR?: Users_KhachHangWhereInput[]
    NOT?: Users_KhachHangWhereInput | Users_KhachHangWhereInput[]
    name?: StringNullableFilter<"Users_KhachHang"> | string | null
    phone?: StringNullableFilter<"Users_KhachHang"> | string | null
    google_id?: StringNullableFilter<"Users_KhachHang"> | string | null
    gender?: EnumGenderFilter<"Users_KhachHang"> | $Enums.Gender
    date_of_birth?: DateTimeFilter<"Users_KhachHang"> | Date | string
    avatar?: StringNullableFilter<"Users_KhachHang"> | string | null
    createdAt?: DateTimeFilter<"Users_KhachHang"> | Date | string
    updatedAt?: DateTimeFilter<"Users_KhachHang"> | Date | string
    id_role_KhachHang?: StringFilter<"Users_KhachHang"> | string
    role?: XOR<Roles_KhachHangRelationFilter, Roles_KhachHangWhereInput>
  }, "id_user_KhachHang" | "id_uk" | "user_name" | "email">

  export type Users_KhachHangOrderByWithAggregationInput = {
    id_user_KhachHang?: SortOrder
    id_uk?: SortOrder
    user_name?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    google_id?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id_role_KhachHang?: SortOrder
    _count?: Users_KhachHangCountOrderByAggregateInput
    _max?: Users_KhachHangMaxOrderByAggregateInput
    _min?: Users_KhachHangMinOrderByAggregateInput
  }

  export type Users_KhachHangScalarWhereWithAggregatesInput = {
    AND?: Users_KhachHangScalarWhereWithAggregatesInput | Users_KhachHangScalarWhereWithAggregatesInput[]
    OR?: Users_KhachHangScalarWhereWithAggregatesInput[]
    NOT?: Users_KhachHangScalarWhereWithAggregatesInput | Users_KhachHangScalarWhereWithAggregatesInput[]
    id_user_KhachHang?: StringWithAggregatesFilter<"Users_KhachHang"> | string
    id_uk?: StringWithAggregatesFilter<"Users_KhachHang"> | string
    user_name?: StringWithAggregatesFilter<"Users_KhachHang"> | string
    name?: StringNullableWithAggregatesFilter<"Users_KhachHang"> | string | null
    email?: StringWithAggregatesFilter<"Users_KhachHang"> | string
    phone?: StringNullableWithAggregatesFilter<"Users_KhachHang"> | string | null
    google_id?: StringNullableWithAggregatesFilter<"Users_KhachHang"> | string | null
    gender?: EnumGenderWithAggregatesFilter<"Users_KhachHang"> | $Enums.Gender
    date_of_birth?: DateTimeWithAggregatesFilter<"Users_KhachHang"> | Date | string
    avatar?: StringNullableWithAggregatesFilter<"Users_KhachHang"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Users_KhachHang"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Users_KhachHang"> | Date | string
    id_role_KhachHang?: StringWithAggregatesFilter<"Users_KhachHang"> | string
  }

  export type Users_StaffWhereInput = {
    AND?: Users_StaffWhereInput | Users_StaffWhereInput[]
    OR?: Users_StaffWhereInput[]
    NOT?: Users_StaffWhereInput | Users_StaffWhereInput[]
    id_user_staff?: StringFilter<"Users_Staff"> | string
    id_ut?: StringFilter<"Users_Staff"> | string
    user_name?: StringFilter<"Users_Staff"> | string
    name?: StringNullableFilter<"Users_Staff"> | string | null
    email?: StringFilter<"Users_Staff"> | string
    phone?: StringNullableFilter<"Users_Staff"> | string | null
    google_id?: StringNullableFilter<"Users_Staff"> | string | null
    gender?: EnumGenderFilter<"Users_Staff"> | $Enums.Gender
    date_of_birth?: DateTimeFilter<"Users_Staff"> | Date | string
    avatar?: StringNullableFilter<"Users_Staff"> | string | null
    createdAt?: DateTimeFilter<"Users_Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Users_Staff"> | Date | string
    id_role_staff?: StringFilter<"Users_Staff"> | string
    role?: XOR<Roles_StaffRelationFilter, Roles_StaffWhereInput>
  }

  export type Users_StaffOrderByWithRelationInput = {
    id_user_staff?: SortOrder
    id_ut?: SortOrder
    user_name?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    google_id?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id_role_staff?: SortOrder
    role?: Roles_StaffOrderByWithRelationInput
  }

  export type Users_StaffWhereUniqueInput = Prisma.AtLeast<{
    id_user_staff?: string
    id_ut?: string
    user_name?: string
    email?: string
    AND?: Users_StaffWhereInput | Users_StaffWhereInput[]
    OR?: Users_StaffWhereInput[]
    NOT?: Users_StaffWhereInput | Users_StaffWhereInput[]
    name?: StringNullableFilter<"Users_Staff"> | string | null
    phone?: StringNullableFilter<"Users_Staff"> | string | null
    google_id?: StringNullableFilter<"Users_Staff"> | string | null
    gender?: EnumGenderFilter<"Users_Staff"> | $Enums.Gender
    date_of_birth?: DateTimeFilter<"Users_Staff"> | Date | string
    avatar?: StringNullableFilter<"Users_Staff"> | string | null
    createdAt?: DateTimeFilter<"Users_Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Users_Staff"> | Date | string
    id_role_staff?: StringFilter<"Users_Staff"> | string
    role?: XOR<Roles_StaffRelationFilter, Roles_StaffWhereInput>
  }, "id_user_staff" | "id_ut" | "user_name" | "email">

  export type Users_StaffOrderByWithAggregationInput = {
    id_user_staff?: SortOrder
    id_ut?: SortOrder
    user_name?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    google_id?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id_role_staff?: SortOrder
    _count?: Users_StaffCountOrderByAggregateInput
    _max?: Users_StaffMaxOrderByAggregateInput
    _min?: Users_StaffMinOrderByAggregateInput
  }

  export type Users_StaffScalarWhereWithAggregatesInput = {
    AND?: Users_StaffScalarWhereWithAggregatesInput | Users_StaffScalarWhereWithAggregatesInput[]
    OR?: Users_StaffScalarWhereWithAggregatesInput[]
    NOT?: Users_StaffScalarWhereWithAggregatesInput | Users_StaffScalarWhereWithAggregatesInput[]
    id_user_staff?: StringWithAggregatesFilter<"Users_Staff"> | string
    id_ut?: StringWithAggregatesFilter<"Users_Staff"> | string
    user_name?: StringWithAggregatesFilter<"Users_Staff"> | string
    name?: StringNullableWithAggregatesFilter<"Users_Staff"> | string | null
    email?: StringWithAggregatesFilter<"Users_Staff"> | string
    phone?: StringNullableWithAggregatesFilter<"Users_Staff"> | string | null
    google_id?: StringNullableWithAggregatesFilter<"Users_Staff"> | string | null
    gender?: EnumGenderWithAggregatesFilter<"Users_Staff"> | $Enums.Gender
    date_of_birth?: DateTimeWithAggregatesFilter<"Users_Staff"> | Date | string
    avatar?: StringNullableWithAggregatesFilter<"Users_Staff"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Users_Staff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Users_Staff"> | Date | string
    id_role_staff?: StringWithAggregatesFilter<"Users_Staff"> | string
  }

  export type BrandsCreateInput = {
    id_brand?: string
    id_b: string
    name: string
    description?: string | null
    logo?: string | null
    status?: $Enums.Status_Brand
    createdAt?: Date | string
    updatedAt?: Date | string
    owners_brand?: Owners_BrandCreateNestedManyWithoutBrandInput
  }

  export type BrandsUncheckedCreateInput = {
    id_brand?: string
    id_b: string
    name: string
    description?: string | null
    logo?: string | null
    status?: $Enums.Status_Brand
    createdAt?: Date | string
    updatedAt?: Date | string
    owners_brand?: Owners_BrandUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandsUpdateInput = {
    id_b?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatus_BrandFieldUpdateOperationsInput | $Enums.Status_Brand
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owners_brand?: Owners_BrandUpdateManyWithoutBrandNestedInput
  }

  export type BrandsUncheckedUpdateInput = {
    id_b?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatus_BrandFieldUpdateOperationsInput | $Enums.Status_Brand
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owners_brand?: Owners_BrandUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type BrandsCreateManyInput = {
    id_brand?: string
    id_b: string
    name: string
    description?: string | null
    logo?: string | null
    status?: $Enums.Status_Brand
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BrandsUpdateManyMutationInput = {
    id_b?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatus_BrandFieldUpdateOperationsInput | $Enums.Status_Brand
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandsUncheckedUpdateManyInput = {
    id_b?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatus_BrandFieldUpdateOperationsInput | $Enums.Status_Brand
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Owners_BrandCreateInput = {
    id_owners_brand?: string
    createdAt?: Date | string
    user_admin: Users_AdminCreateNestedOneWithoutOwners_brandInput
    brand: BrandsCreateNestedOneWithoutOwners_brandInput
  }

  export type Owners_BrandUncheckedCreateInput = {
    id_owners_brand?: string
    id_brand: string
    id_user_admin: string
    createdAt?: Date | string
  }

  export type Owners_BrandUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_admin?: Users_AdminUpdateOneRequiredWithoutOwners_brandNestedInput
    brand?: BrandsUpdateOneRequiredWithoutOwners_brandNestedInput
  }

  export type Owners_BrandUncheckedUpdateInput = {
    id_brand?: StringFieldUpdateOperationsInput | string
    id_user_admin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Owners_BrandCreateManyInput = {
    id_owners_brand?: string
    id_brand: string
    id_user_admin: string
    createdAt?: Date | string
  }

  export type Owners_BrandUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Owners_BrandUncheckedUpdateManyInput = {
    id_brand?: StringFieldUpdateOperationsInput | string
    id_user_admin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Roles_AdminCreateInput = {
    id_role_admin?: string
    id_ra: string
    name: string
    description?: string | null
    users_admin?: Users_AdminCreateNestedManyWithoutRoleInput
  }

  export type Roles_AdminUncheckedCreateInput = {
    id_role_admin?: string
    id_ra: string
    name: string
    description?: string | null
    users_admin?: Users_AdminUncheckedCreateNestedManyWithoutRoleInput
  }

  export type Roles_AdminUpdateInput = {
    id_ra?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users_admin?: Users_AdminUpdateManyWithoutRoleNestedInput
  }

  export type Roles_AdminUncheckedUpdateInput = {
    id_ra?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users_admin?: Users_AdminUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type Roles_AdminCreateManyInput = {
    id_role_admin?: string
    id_ra: string
    name: string
    description?: string | null
  }

  export type Roles_AdminUpdateManyMutationInput = {
    id_ra?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Roles_AdminUncheckedUpdateManyInput = {
    id_ra?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Roles_KhachHangCreateInput = {
    id_role_KhachHang?: string
    id_rkh: string
    name: string
    description?: string | null
    users_khachhang?: Users_KhachHangCreateNestedManyWithoutRoleInput
  }

  export type Roles_KhachHangUncheckedCreateInput = {
    id_role_KhachHang?: string
    id_rkh: string
    name: string
    description?: string | null
    users_khachhang?: Users_KhachHangUncheckedCreateNestedManyWithoutRoleInput
  }

  export type Roles_KhachHangUpdateInput = {
    id_rkh?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users_khachhang?: Users_KhachHangUpdateManyWithoutRoleNestedInput
  }

  export type Roles_KhachHangUncheckedUpdateInput = {
    id_rkh?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users_khachhang?: Users_KhachHangUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type Roles_KhachHangCreateManyInput = {
    id_role_KhachHang?: string
    id_rkh: string
    name: string
    description?: string | null
  }

  export type Roles_KhachHangUpdateManyMutationInput = {
    id_rkh?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Roles_KhachHangUncheckedUpdateManyInput = {
    id_rkh?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Roles_StaffCreateInput = {
    id_role_staff?: string
    id_rt: string
    name: string
    description?: string | null
    users_staff?: Users_StaffCreateNestedManyWithoutRoleInput
  }

  export type Roles_StaffUncheckedCreateInput = {
    id_role_staff?: string
    id_rt: string
    name: string
    description?: string | null
    users_staff?: Users_StaffUncheckedCreateNestedManyWithoutRoleInput
  }

  export type Roles_StaffUpdateInput = {
    id_rt?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users_staff?: Users_StaffUpdateManyWithoutRoleNestedInput
  }

  export type Roles_StaffUncheckedUpdateInput = {
    id_rt?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users_staff?: Users_StaffUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type Roles_StaffCreateManyInput = {
    id_role_staff?: string
    id_rt: string
    name: string
    description?: string | null
  }

  export type Roles_StaffUpdateManyMutationInput = {
    id_rt?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Roles_StaffUncheckedUpdateManyInput = {
    id_rt?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Users_AdminCreateInput = {
    id_user_admin?: string
    id_ud: string
    user_name: string
    name?: string | null
    email: string
    phone?: string | null
    password_hash: string
    google_id?: string | null
    gender: $Enums.Gender
    date_of_birth: Date | string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: Roles_AdminCreateNestedOneWithoutUsers_adminInput
    owners_brand?: Owners_BrandCreateNestedManyWithoutUser_adminInput
  }

  export type Users_AdminUncheckedCreateInput = {
    id_user_admin?: string
    id_ud: string
    user_name: string
    name?: string | null
    email: string
    phone?: string | null
    password_hash: string
    google_id?: string | null
    gender: $Enums.Gender
    date_of_birth: Date | string
    avatar?: string | null
    id_role_admin: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owners_brand?: Owners_BrandUncheckedCreateNestedManyWithoutUser_adminInput
  }

  export type Users_AdminUpdateInput = {
    id_ud?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: Roles_AdminUpdateOneRequiredWithoutUsers_adminNestedInput
    owners_brand?: Owners_BrandUpdateManyWithoutUser_adminNestedInput
  }

  export type Users_AdminUncheckedUpdateInput = {
    id_ud?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    id_role_admin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owners_brand?: Owners_BrandUncheckedUpdateManyWithoutUser_adminNestedInput
  }

  export type Users_AdminCreateManyInput = {
    id_user_admin?: string
    id_ud: string
    user_name: string
    name?: string | null
    email: string
    phone?: string | null
    password_hash: string
    google_id?: string | null
    gender: $Enums.Gender
    date_of_birth: Date | string
    avatar?: string | null
    id_role_admin: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Users_AdminUpdateManyMutationInput = {
    id_ud?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Users_AdminUncheckedUpdateManyInput = {
    id_ud?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    id_role_admin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Users_KhachHangCreateInput = {
    id_user_KhachHang?: string
    id_uk: string
    user_name: string
    name?: string | null
    email: string
    phone?: string | null
    google_id?: string | null
    gender: $Enums.Gender
    date_of_birth: Date | string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: Roles_KhachHangCreateNestedOneWithoutUsers_khachhangInput
  }

  export type Users_KhachHangUncheckedCreateInput = {
    id_user_KhachHang?: string
    id_uk: string
    user_name: string
    name?: string | null
    email: string
    phone?: string | null
    google_id?: string | null
    gender: $Enums.Gender
    date_of_birth: Date | string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id_role_KhachHang: string
  }

  export type Users_KhachHangUpdateInput = {
    id_uk?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: Roles_KhachHangUpdateOneRequiredWithoutUsers_khachhangNestedInput
  }

  export type Users_KhachHangUncheckedUpdateInput = {
    id_uk?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id_role_KhachHang?: StringFieldUpdateOperationsInput | string
  }

  export type Users_KhachHangCreateManyInput = {
    id_user_KhachHang?: string
    id_uk: string
    user_name: string
    name?: string | null
    email: string
    phone?: string | null
    google_id?: string | null
    gender: $Enums.Gender
    date_of_birth: Date | string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id_role_KhachHang: string
  }

  export type Users_KhachHangUpdateManyMutationInput = {
    id_uk?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Users_KhachHangUncheckedUpdateManyInput = {
    id_uk?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id_role_KhachHang?: StringFieldUpdateOperationsInput | string
  }

  export type Users_StaffCreateInput = {
    id_user_staff?: string
    id_ut: string
    user_name: string
    name?: string | null
    email: string
    phone?: string | null
    google_id?: string | null
    gender: $Enums.Gender
    date_of_birth: Date | string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: Roles_StaffCreateNestedOneWithoutUsers_staffInput
  }

  export type Users_StaffUncheckedCreateInput = {
    id_user_staff?: string
    id_ut: string
    user_name: string
    name?: string | null
    email: string
    phone?: string | null
    google_id?: string | null
    gender: $Enums.Gender
    date_of_birth: Date | string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id_role_staff: string
  }

  export type Users_StaffUpdateInput = {
    id_ut?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: Roles_StaffUpdateOneRequiredWithoutUsers_staffNestedInput
  }

  export type Users_StaffUncheckedUpdateInput = {
    id_ut?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id_role_staff?: StringFieldUpdateOperationsInput | string
  }

  export type Users_StaffCreateManyInput = {
    id_user_staff?: string
    id_ut: string
    user_name: string
    name?: string | null
    email: string
    phone?: string | null
    google_id?: string | null
    gender: $Enums.Gender
    date_of_birth: Date | string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id_role_staff: string
  }

  export type Users_StaffUpdateManyMutationInput = {
    id_ut?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Users_StaffUncheckedUpdateManyInput = {
    id_ut?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id_role_staff?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type EnumStatus_BrandFilter<$PrismaModel = never> = {
    equals?: $Enums.Status_Brand | EnumStatus_BrandFieldRefInput<$PrismaModel>
    in?: $Enums.Status_Brand[] | ListEnumStatus_BrandFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status_Brand[] | ListEnumStatus_BrandFieldRefInput<$PrismaModel>
    not?: NestedEnumStatus_BrandFilter<$PrismaModel> | $Enums.Status_Brand
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type Owners_BrandListRelationFilter = {
    every?: Owners_BrandWhereInput
    some?: Owners_BrandWhereInput
    none?: Owners_BrandWhereInput
  }

  export type Owners_BrandOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BrandsCountOrderByAggregateInput = {
    id_brand?: SortOrder
    id_b?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandsMaxOrderByAggregateInput = {
    id_brand?: SortOrder
    id_b?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandsMinOrderByAggregateInput = {
    id_brand?: SortOrder
    id_b?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumStatus_BrandWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status_Brand | EnumStatus_BrandFieldRefInput<$PrismaModel>
    in?: $Enums.Status_Brand[] | ListEnumStatus_BrandFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status_Brand[] | ListEnumStatus_BrandFieldRefInput<$PrismaModel>
    not?: NestedEnumStatus_BrandWithAggregatesFilter<$PrismaModel> | $Enums.Status_Brand
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatus_BrandFilter<$PrismaModel>
    _max?: NestedEnumStatus_BrandFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type Users_AdminRelationFilter = {
    is?: Users_AdminWhereInput
    isNot?: Users_AdminWhereInput
  }

  export type BrandsRelationFilter = {
    is?: BrandsWhereInput
    isNot?: BrandsWhereInput
  }

  export type Owners_BrandCountOrderByAggregateInput = {
    id_owners_brand?: SortOrder
    id_brand?: SortOrder
    id_user_admin?: SortOrder
    createdAt?: SortOrder
  }

  export type Owners_BrandMaxOrderByAggregateInput = {
    id_owners_brand?: SortOrder
    id_brand?: SortOrder
    id_user_admin?: SortOrder
    createdAt?: SortOrder
  }

  export type Owners_BrandMinOrderByAggregateInput = {
    id_owners_brand?: SortOrder
    id_brand?: SortOrder
    id_user_admin?: SortOrder
    createdAt?: SortOrder
  }

  export type Users_AdminListRelationFilter = {
    every?: Users_AdminWhereInput
    some?: Users_AdminWhereInput
    none?: Users_AdminWhereInput
  }

  export type Users_AdminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Roles_AdminCountOrderByAggregateInput = {
    id_role_admin?: SortOrder
    id_ra?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type Roles_AdminMaxOrderByAggregateInput = {
    id_role_admin?: SortOrder
    id_ra?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type Roles_AdminMinOrderByAggregateInput = {
    id_role_admin?: SortOrder
    id_ra?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type Users_KhachHangListRelationFilter = {
    every?: Users_KhachHangWhereInput
    some?: Users_KhachHangWhereInput
    none?: Users_KhachHangWhereInput
  }

  export type Users_KhachHangOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Roles_KhachHangCountOrderByAggregateInput = {
    id_role_KhachHang?: SortOrder
    id_rkh?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type Roles_KhachHangMaxOrderByAggregateInput = {
    id_role_KhachHang?: SortOrder
    id_rkh?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type Roles_KhachHangMinOrderByAggregateInput = {
    id_role_KhachHang?: SortOrder
    id_rkh?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type Users_StaffListRelationFilter = {
    every?: Users_StaffWhereInput
    some?: Users_StaffWhereInput
    none?: Users_StaffWhereInput
  }

  export type Users_StaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Roles_StaffCountOrderByAggregateInput = {
    id_role_staff?: SortOrder
    id_rt?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type Roles_StaffMaxOrderByAggregateInput = {
    id_role_staff?: SortOrder
    id_rt?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type Roles_StaffMinOrderByAggregateInput = {
    id_role_staff?: SortOrder
    id_rt?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type Roles_AdminRelationFilter = {
    is?: Roles_AdminWhereInput
    isNot?: Roles_AdminWhereInput
  }

  export type Users_AdminCountOrderByAggregateInput = {
    id_user_admin?: SortOrder
    id_ud?: SortOrder
    user_name?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password_hash?: SortOrder
    google_id?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    avatar?: SortOrder
    id_role_admin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Users_AdminMaxOrderByAggregateInput = {
    id_user_admin?: SortOrder
    id_ud?: SortOrder
    user_name?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password_hash?: SortOrder
    google_id?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    avatar?: SortOrder
    id_role_admin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Users_AdminMinOrderByAggregateInput = {
    id_user_admin?: SortOrder
    id_ud?: SortOrder
    user_name?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password_hash?: SortOrder
    google_id?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    avatar?: SortOrder
    id_role_admin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type Roles_KhachHangRelationFilter = {
    is?: Roles_KhachHangWhereInput
    isNot?: Roles_KhachHangWhereInput
  }

  export type Users_KhachHangCountOrderByAggregateInput = {
    id_user_KhachHang?: SortOrder
    id_uk?: SortOrder
    user_name?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    google_id?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id_role_KhachHang?: SortOrder
  }

  export type Users_KhachHangMaxOrderByAggregateInput = {
    id_user_KhachHang?: SortOrder
    id_uk?: SortOrder
    user_name?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    google_id?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id_role_KhachHang?: SortOrder
  }

  export type Users_KhachHangMinOrderByAggregateInput = {
    id_user_KhachHang?: SortOrder
    id_uk?: SortOrder
    user_name?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    google_id?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id_role_KhachHang?: SortOrder
  }

  export type Roles_StaffRelationFilter = {
    is?: Roles_StaffWhereInput
    isNot?: Roles_StaffWhereInput
  }

  export type Users_StaffCountOrderByAggregateInput = {
    id_user_staff?: SortOrder
    id_ut?: SortOrder
    user_name?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    google_id?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id_role_staff?: SortOrder
  }

  export type Users_StaffMaxOrderByAggregateInput = {
    id_user_staff?: SortOrder
    id_ut?: SortOrder
    user_name?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    google_id?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id_role_staff?: SortOrder
  }

  export type Users_StaffMinOrderByAggregateInput = {
    id_user_staff?: SortOrder
    id_ut?: SortOrder
    user_name?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    google_id?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id_role_staff?: SortOrder
  }

  export type Owners_BrandCreateNestedManyWithoutBrandInput = {
    create?: XOR<Owners_BrandCreateWithoutBrandInput, Owners_BrandUncheckedCreateWithoutBrandInput> | Owners_BrandCreateWithoutBrandInput[] | Owners_BrandUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: Owners_BrandCreateOrConnectWithoutBrandInput | Owners_BrandCreateOrConnectWithoutBrandInput[]
    createMany?: Owners_BrandCreateManyBrandInputEnvelope
    connect?: Owners_BrandWhereUniqueInput | Owners_BrandWhereUniqueInput[]
  }

  export type Owners_BrandUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<Owners_BrandCreateWithoutBrandInput, Owners_BrandUncheckedCreateWithoutBrandInput> | Owners_BrandCreateWithoutBrandInput[] | Owners_BrandUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: Owners_BrandCreateOrConnectWithoutBrandInput | Owners_BrandCreateOrConnectWithoutBrandInput[]
    createMany?: Owners_BrandCreateManyBrandInputEnvelope
    connect?: Owners_BrandWhereUniqueInput | Owners_BrandWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type EnumStatus_BrandFieldUpdateOperationsInput = {
    set?: $Enums.Status_Brand
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type Owners_BrandUpdateManyWithoutBrandNestedInput = {
    create?: XOR<Owners_BrandCreateWithoutBrandInput, Owners_BrandUncheckedCreateWithoutBrandInput> | Owners_BrandCreateWithoutBrandInput[] | Owners_BrandUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: Owners_BrandCreateOrConnectWithoutBrandInput | Owners_BrandCreateOrConnectWithoutBrandInput[]
    upsert?: Owners_BrandUpsertWithWhereUniqueWithoutBrandInput | Owners_BrandUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: Owners_BrandCreateManyBrandInputEnvelope
    set?: Owners_BrandWhereUniqueInput | Owners_BrandWhereUniqueInput[]
    disconnect?: Owners_BrandWhereUniqueInput | Owners_BrandWhereUniqueInput[]
    delete?: Owners_BrandWhereUniqueInput | Owners_BrandWhereUniqueInput[]
    connect?: Owners_BrandWhereUniqueInput | Owners_BrandWhereUniqueInput[]
    update?: Owners_BrandUpdateWithWhereUniqueWithoutBrandInput | Owners_BrandUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: Owners_BrandUpdateManyWithWhereWithoutBrandInput | Owners_BrandUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: Owners_BrandScalarWhereInput | Owners_BrandScalarWhereInput[]
  }

  export type Owners_BrandUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<Owners_BrandCreateWithoutBrandInput, Owners_BrandUncheckedCreateWithoutBrandInput> | Owners_BrandCreateWithoutBrandInput[] | Owners_BrandUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: Owners_BrandCreateOrConnectWithoutBrandInput | Owners_BrandCreateOrConnectWithoutBrandInput[]
    upsert?: Owners_BrandUpsertWithWhereUniqueWithoutBrandInput | Owners_BrandUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: Owners_BrandCreateManyBrandInputEnvelope
    set?: Owners_BrandWhereUniqueInput | Owners_BrandWhereUniqueInput[]
    disconnect?: Owners_BrandWhereUniqueInput | Owners_BrandWhereUniqueInput[]
    delete?: Owners_BrandWhereUniqueInput | Owners_BrandWhereUniqueInput[]
    connect?: Owners_BrandWhereUniqueInput | Owners_BrandWhereUniqueInput[]
    update?: Owners_BrandUpdateWithWhereUniqueWithoutBrandInput | Owners_BrandUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: Owners_BrandUpdateManyWithWhereWithoutBrandInput | Owners_BrandUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: Owners_BrandScalarWhereInput | Owners_BrandScalarWhereInput[]
  }

  export type Users_AdminCreateNestedOneWithoutOwners_brandInput = {
    create?: XOR<Users_AdminCreateWithoutOwners_brandInput, Users_AdminUncheckedCreateWithoutOwners_brandInput>
    connectOrCreate?: Users_AdminCreateOrConnectWithoutOwners_brandInput
    connect?: Users_AdminWhereUniqueInput
  }

  export type BrandsCreateNestedOneWithoutOwners_brandInput = {
    create?: XOR<BrandsCreateWithoutOwners_brandInput, BrandsUncheckedCreateWithoutOwners_brandInput>
    connectOrCreate?: BrandsCreateOrConnectWithoutOwners_brandInput
    connect?: BrandsWhereUniqueInput
  }

  export type Users_AdminUpdateOneRequiredWithoutOwners_brandNestedInput = {
    create?: XOR<Users_AdminCreateWithoutOwners_brandInput, Users_AdminUncheckedCreateWithoutOwners_brandInput>
    connectOrCreate?: Users_AdminCreateOrConnectWithoutOwners_brandInput
    upsert?: Users_AdminUpsertWithoutOwners_brandInput
    connect?: Users_AdminWhereUniqueInput
    update?: XOR<XOR<Users_AdminUpdateToOneWithWhereWithoutOwners_brandInput, Users_AdminUpdateWithoutOwners_brandInput>, Users_AdminUncheckedUpdateWithoutOwners_brandInput>
  }

  export type BrandsUpdateOneRequiredWithoutOwners_brandNestedInput = {
    create?: XOR<BrandsCreateWithoutOwners_brandInput, BrandsUncheckedCreateWithoutOwners_brandInput>
    connectOrCreate?: BrandsCreateOrConnectWithoutOwners_brandInput
    upsert?: BrandsUpsertWithoutOwners_brandInput
    connect?: BrandsWhereUniqueInput
    update?: XOR<XOR<BrandsUpdateToOneWithWhereWithoutOwners_brandInput, BrandsUpdateWithoutOwners_brandInput>, BrandsUncheckedUpdateWithoutOwners_brandInput>
  }

  export type Users_AdminCreateNestedManyWithoutRoleInput = {
    create?: XOR<Users_AdminCreateWithoutRoleInput, Users_AdminUncheckedCreateWithoutRoleInput> | Users_AdminCreateWithoutRoleInput[] | Users_AdminUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: Users_AdminCreateOrConnectWithoutRoleInput | Users_AdminCreateOrConnectWithoutRoleInput[]
    createMany?: Users_AdminCreateManyRoleInputEnvelope
    connect?: Users_AdminWhereUniqueInput | Users_AdminWhereUniqueInput[]
  }

  export type Users_AdminUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<Users_AdminCreateWithoutRoleInput, Users_AdminUncheckedCreateWithoutRoleInput> | Users_AdminCreateWithoutRoleInput[] | Users_AdminUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: Users_AdminCreateOrConnectWithoutRoleInput | Users_AdminCreateOrConnectWithoutRoleInput[]
    createMany?: Users_AdminCreateManyRoleInputEnvelope
    connect?: Users_AdminWhereUniqueInput | Users_AdminWhereUniqueInput[]
  }

  export type Users_AdminUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Users_AdminCreateWithoutRoleInput, Users_AdminUncheckedCreateWithoutRoleInput> | Users_AdminCreateWithoutRoleInput[] | Users_AdminUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: Users_AdminCreateOrConnectWithoutRoleInput | Users_AdminCreateOrConnectWithoutRoleInput[]
    upsert?: Users_AdminUpsertWithWhereUniqueWithoutRoleInput | Users_AdminUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: Users_AdminCreateManyRoleInputEnvelope
    set?: Users_AdminWhereUniqueInput | Users_AdminWhereUniqueInput[]
    disconnect?: Users_AdminWhereUniqueInput | Users_AdminWhereUniqueInput[]
    delete?: Users_AdminWhereUniqueInput | Users_AdminWhereUniqueInput[]
    connect?: Users_AdminWhereUniqueInput | Users_AdminWhereUniqueInput[]
    update?: Users_AdminUpdateWithWhereUniqueWithoutRoleInput | Users_AdminUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: Users_AdminUpdateManyWithWhereWithoutRoleInput | Users_AdminUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: Users_AdminScalarWhereInput | Users_AdminScalarWhereInput[]
  }

  export type Users_AdminUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Users_AdminCreateWithoutRoleInput, Users_AdminUncheckedCreateWithoutRoleInput> | Users_AdminCreateWithoutRoleInput[] | Users_AdminUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: Users_AdminCreateOrConnectWithoutRoleInput | Users_AdminCreateOrConnectWithoutRoleInput[]
    upsert?: Users_AdminUpsertWithWhereUniqueWithoutRoleInput | Users_AdminUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: Users_AdminCreateManyRoleInputEnvelope
    set?: Users_AdminWhereUniqueInput | Users_AdminWhereUniqueInput[]
    disconnect?: Users_AdminWhereUniqueInput | Users_AdminWhereUniqueInput[]
    delete?: Users_AdminWhereUniqueInput | Users_AdminWhereUniqueInput[]
    connect?: Users_AdminWhereUniqueInput | Users_AdminWhereUniqueInput[]
    update?: Users_AdminUpdateWithWhereUniqueWithoutRoleInput | Users_AdminUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: Users_AdminUpdateManyWithWhereWithoutRoleInput | Users_AdminUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: Users_AdminScalarWhereInput | Users_AdminScalarWhereInput[]
  }

  export type Users_KhachHangCreateNestedManyWithoutRoleInput = {
    create?: XOR<Users_KhachHangCreateWithoutRoleInput, Users_KhachHangUncheckedCreateWithoutRoleInput> | Users_KhachHangCreateWithoutRoleInput[] | Users_KhachHangUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: Users_KhachHangCreateOrConnectWithoutRoleInput | Users_KhachHangCreateOrConnectWithoutRoleInput[]
    createMany?: Users_KhachHangCreateManyRoleInputEnvelope
    connect?: Users_KhachHangWhereUniqueInput | Users_KhachHangWhereUniqueInput[]
  }

  export type Users_KhachHangUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<Users_KhachHangCreateWithoutRoleInput, Users_KhachHangUncheckedCreateWithoutRoleInput> | Users_KhachHangCreateWithoutRoleInput[] | Users_KhachHangUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: Users_KhachHangCreateOrConnectWithoutRoleInput | Users_KhachHangCreateOrConnectWithoutRoleInput[]
    createMany?: Users_KhachHangCreateManyRoleInputEnvelope
    connect?: Users_KhachHangWhereUniqueInput | Users_KhachHangWhereUniqueInput[]
  }

  export type Users_KhachHangUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Users_KhachHangCreateWithoutRoleInput, Users_KhachHangUncheckedCreateWithoutRoleInput> | Users_KhachHangCreateWithoutRoleInput[] | Users_KhachHangUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: Users_KhachHangCreateOrConnectWithoutRoleInput | Users_KhachHangCreateOrConnectWithoutRoleInput[]
    upsert?: Users_KhachHangUpsertWithWhereUniqueWithoutRoleInput | Users_KhachHangUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: Users_KhachHangCreateManyRoleInputEnvelope
    set?: Users_KhachHangWhereUniqueInput | Users_KhachHangWhereUniqueInput[]
    disconnect?: Users_KhachHangWhereUniqueInput | Users_KhachHangWhereUniqueInput[]
    delete?: Users_KhachHangWhereUniqueInput | Users_KhachHangWhereUniqueInput[]
    connect?: Users_KhachHangWhereUniqueInput | Users_KhachHangWhereUniqueInput[]
    update?: Users_KhachHangUpdateWithWhereUniqueWithoutRoleInput | Users_KhachHangUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: Users_KhachHangUpdateManyWithWhereWithoutRoleInput | Users_KhachHangUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: Users_KhachHangScalarWhereInput | Users_KhachHangScalarWhereInput[]
  }

  export type Users_KhachHangUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Users_KhachHangCreateWithoutRoleInput, Users_KhachHangUncheckedCreateWithoutRoleInput> | Users_KhachHangCreateWithoutRoleInput[] | Users_KhachHangUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: Users_KhachHangCreateOrConnectWithoutRoleInput | Users_KhachHangCreateOrConnectWithoutRoleInput[]
    upsert?: Users_KhachHangUpsertWithWhereUniqueWithoutRoleInput | Users_KhachHangUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: Users_KhachHangCreateManyRoleInputEnvelope
    set?: Users_KhachHangWhereUniqueInput | Users_KhachHangWhereUniqueInput[]
    disconnect?: Users_KhachHangWhereUniqueInput | Users_KhachHangWhereUniqueInput[]
    delete?: Users_KhachHangWhereUniqueInput | Users_KhachHangWhereUniqueInput[]
    connect?: Users_KhachHangWhereUniqueInput | Users_KhachHangWhereUniqueInput[]
    update?: Users_KhachHangUpdateWithWhereUniqueWithoutRoleInput | Users_KhachHangUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: Users_KhachHangUpdateManyWithWhereWithoutRoleInput | Users_KhachHangUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: Users_KhachHangScalarWhereInput | Users_KhachHangScalarWhereInput[]
  }

  export type Users_StaffCreateNestedManyWithoutRoleInput = {
    create?: XOR<Users_StaffCreateWithoutRoleInput, Users_StaffUncheckedCreateWithoutRoleInput> | Users_StaffCreateWithoutRoleInput[] | Users_StaffUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: Users_StaffCreateOrConnectWithoutRoleInput | Users_StaffCreateOrConnectWithoutRoleInput[]
    createMany?: Users_StaffCreateManyRoleInputEnvelope
    connect?: Users_StaffWhereUniqueInput | Users_StaffWhereUniqueInput[]
  }

  export type Users_StaffUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<Users_StaffCreateWithoutRoleInput, Users_StaffUncheckedCreateWithoutRoleInput> | Users_StaffCreateWithoutRoleInput[] | Users_StaffUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: Users_StaffCreateOrConnectWithoutRoleInput | Users_StaffCreateOrConnectWithoutRoleInput[]
    createMany?: Users_StaffCreateManyRoleInputEnvelope
    connect?: Users_StaffWhereUniqueInput | Users_StaffWhereUniqueInput[]
  }

  export type Users_StaffUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Users_StaffCreateWithoutRoleInput, Users_StaffUncheckedCreateWithoutRoleInput> | Users_StaffCreateWithoutRoleInput[] | Users_StaffUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: Users_StaffCreateOrConnectWithoutRoleInput | Users_StaffCreateOrConnectWithoutRoleInput[]
    upsert?: Users_StaffUpsertWithWhereUniqueWithoutRoleInput | Users_StaffUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: Users_StaffCreateManyRoleInputEnvelope
    set?: Users_StaffWhereUniqueInput | Users_StaffWhereUniqueInput[]
    disconnect?: Users_StaffWhereUniqueInput | Users_StaffWhereUniqueInput[]
    delete?: Users_StaffWhereUniqueInput | Users_StaffWhereUniqueInput[]
    connect?: Users_StaffWhereUniqueInput | Users_StaffWhereUniqueInput[]
    update?: Users_StaffUpdateWithWhereUniqueWithoutRoleInput | Users_StaffUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: Users_StaffUpdateManyWithWhereWithoutRoleInput | Users_StaffUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: Users_StaffScalarWhereInput | Users_StaffScalarWhereInput[]
  }

  export type Users_StaffUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Users_StaffCreateWithoutRoleInput, Users_StaffUncheckedCreateWithoutRoleInput> | Users_StaffCreateWithoutRoleInput[] | Users_StaffUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: Users_StaffCreateOrConnectWithoutRoleInput | Users_StaffCreateOrConnectWithoutRoleInput[]
    upsert?: Users_StaffUpsertWithWhereUniqueWithoutRoleInput | Users_StaffUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: Users_StaffCreateManyRoleInputEnvelope
    set?: Users_StaffWhereUniqueInput | Users_StaffWhereUniqueInput[]
    disconnect?: Users_StaffWhereUniqueInput | Users_StaffWhereUniqueInput[]
    delete?: Users_StaffWhereUniqueInput | Users_StaffWhereUniqueInput[]
    connect?: Users_StaffWhereUniqueInput | Users_StaffWhereUniqueInput[]
    update?: Users_StaffUpdateWithWhereUniqueWithoutRoleInput | Users_StaffUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: Users_StaffUpdateManyWithWhereWithoutRoleInput | Users_StaffUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: Users_StaffScalarWhereInput | Users_StaffScalarWhereInput[]
  }

  export type Roles_AdminCreateNestedOneWithoutUsers_adminInput = {
    create?: XOR<Roles_AdminCreateWithoutUsers_adminInput, Roles_AdminUncheckedCreateWithoutUsers_adminInput>
    connectOrCreate?: Roles_AdminCreateOrConnectWithoutUsers_adminInput
    connect?: Roles_AdminWhereUniqueInput
  }

  export type Owners_BrandCreateNestedManyWithoutUser_adminInput = {
    create?: XOR<Owners_BrandCreateWithoutUser_adminInput, Owners_BrandUncheckedCreateWithoutUser_adminInput> | Owners_BrandCreateWithoutUser_adminInput[] | Owners_BrandUncheckedCreateWithoutUser_adminInput[]
    connectOrCreate?: Owners_BrandCreateOrConnectWithoutUser_adminInput | Owners_BrandCreateOrConnectWithoutUser_adminInput[]
    createMany?: Owners_BrandCreateManyUser_adminInputEnvelope
    connect?: Owners_BrandWhereUniqueInput | Owners_BrandWhereUniqueInput[]
  }

  export type Owners_BrandUncheckedCreateNestedManyWithoutUser_adminInput = {
    create?: XOR<Owners_BrandCreateWithoutUser_adminInput, Owners_BrandUncheckedCreateWithoutUser_adminInput> | Owners_BrandCreateWithoutUser_adminInput[] | Owners_BrandUncheckedCreateWithoutUser_adminInput[]
    connectOrCreate?: Owners_BrandCreateOrConnectWithoutUser_adminInput | Owners_BrandCreateOrConnectWithoutUser_adminInput[]
    createMany?: Owners_BrandCreateManyUser_adminInputEnvelope
    connect?: Owners_BrandWhereUniqueInput | Owners_BrandWhereUniqueInput[]
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type Roles_AdminUpdateOneRequiredWithoutUsers_adminNestedInput = {
    create?: XOR<Roles_AdminCreateWithoutUsers_adminInput, Roles_AdminUncheckedCreateWithoutUsers_adminInput>
    connectOrCreate?: Roles_AdminCreateOrConnectWithoutUsers_adminInput
    upsert?: Roles_AdminUpsertWithoutUsers_adminInput
    connect?: Roles_AdminWhereUniqueInput
    update?: XOR<XOR<Roles_AdminUpdateToOneWithWhereWithoutUsers_adminInput, Roles_AdminUpdateWithoutUsers_adminInput>, Roles_AdminUncheckedUpdateWithoutUsers_adminInput>
  }

  export type Owners_BrandUpdateManyWithoutUser_adminNestedInput = {
    create?: XOR<Owners_BrandCreateWithoutUser_adminInput, Owners_BrandUncheckedCreateWithoutUser_adminInput> | Owners_BrandCreateWithoutUser_adminInput[] | Owners_BrandUncheckedCreateWithoutUser_adminInput[]
    connectOrCreate?: Owners_BrandCreateOrConnectWithoutUser_adminInput | Owners_BrandCreateOrConnectWithoutUser_adminInput[]
    upsert?: Owners_BrandUpsertWithWhereUniqueWithoutUser_adminInput | Owners_BrandUpsertWithWhereUniqueWithoutUser_adminInput[]
    createMany?: Owners_BrandCreateManyUser_adminInputEnvelope
    set?: Owners_BrandWhereUniqueInput | Owners_BrandWhereUniqueInput[]
    disconnect?: Owners_BrandWhereUniqueInput | Owners_BrandWhereUniqueInput[]
    delete?: Owners_BrandWhereUniqueInput | Owners_BrandWhereUniqueInput[]
    connect?: Owners_BrandWhereUniqueInput | Owners_BrandWhereUniqueInput[]
    update?: Owners_BrandUpdateWithWhereUniqueWithoutUser_adminInput | Owners_BrandUpdateWithWhereUniqueWithoutUser_adminInput[]
    updateMany?: Owners_BrandUpdateManyWithWhereWithoutUser_adminInput | Owners_BrandUpdateManyWithWhereWithoutUser_adminInput[]
    deleteMany?: Owners_BrandScalarWhereInput | Owners_BrandScalarWhereInput[]
  }

  export type Owners_BrandUncheckedUpdateManyWithoutUser_adminNestedInput = {
    create?: XOR<Owners_BrandCreateWithoutUser_adminInput, Owners_BrandUncheckedCreateWithoutUser_adminInput> | Owners_BrandCreateWithoutUser_adminInput[] | Owners_BrandUncheckedCreateWithoutUser_adminInput[]
    connectOrCreate?: Owners_BrandCreateOrConnectWithoutUser_adminInput | Owners_BrandCreateOrConnectWithoutUser_adminInput[]
    upsert?: Owners_BrandUpsertWithWhereUniqueWithoutUser_adminInput | Owners_BrandUpsertWithWhereUniqueWithoutUser_adminInput[]
    createMany?: Owners_BrandCreateManyUser_adminInputEnvelope
    set?: Owners_BrandWhereUniqueInput | Owners_BrandWhereUniqueInput[]
    disconnect?: Owners_BrandWhereUniqueInput | Owners_BrandWhereUniqueInput[]
    delete?: Owners_BrandWhereUniqueInput | Owners_BrandWhereUniqueInput[]
    connect?: Owners_BrandWhereUniqueInput | Owners_BrandWhereUniqueInput[]
    update?: Owners_BrandUpdateWithWhereUniqueWithoutUser_adminInput | Owners_BrandUpdateWithWhereUniqueWithoutUser_adminInput[]
    updateMany?: Owners_BrandUpdateManyWithWhereWithoutUser_adminInput | Owners_BrandUpdateManyWithWhereWithoutUser_adminInput[]
    deleteMany?: Owners_BrandScalarWhereInput | Owners_BrandScalarWhereInput[]
  }

  export type Roles_KhachHangCreateNestedOneWithoutUsers_khachhangInput = {
    create?: XOR<Roles_KhachHangCreateWithoutUsers_khachhangInput, Roles_KhachHangUncheckedCreateWithoutUsers_khachhangInput>
    connectOrCreate?: Roles_KhachHangCreateOrConnectWithoutUsers_khachhangInput
    connect?: Roles_KhachHangWhereUniqueInput
  }

  export type Roles_KhachHangUpdateOneRequiredWithoutUsers_khachhangNestedInput = {
    create?: XOR<Roles_KhachHangCreateWithoutUsers_khachhangInput, Roles_KhachHangUncheckedCreateWithoutUsers_khachhangInput>
    connectOrCreate?: Roles_KhachHangCreateOrConnectWithoutUsers_khachhangInput
    upsert?: Roles_KhachHangUpsertWithoutUsers_khachhangInput
    connect?: Roles_KhachHangWhereUniqueInput
    update?: XOR<XOR<Roles_KhachHangUpdateToOneWithWhereWithoutUsers_khachhangInput, Roles_KhachHangUpdateWithoutUsers_khachhangInput>, Roles_KhachHangUncheckedUpdateWithoutUsers_khachhangInput>
  }

  export type Roles_StaffCreateNestedOneWithoutUsers_staffInput = {
    create?: XOR<Roles_StaffCreateWithoutUsers_staffInput, Roles_StaffUncheckedCreateWithoutUsers_staffInput>
    connectOrCreate?: Roles_StaffCreateOrConnectWithoutUsers_staffInput
    connect?: Roles_StaffWhereUniqueInput
  }

  export type Roles_StaffUpdateOneRequiredWithoutUsers_staffNestedInput = {
    create?: XOR<Roles_StaffCreateWithoutUsers_staffInput, Roles_StaffUncheckedCreateWithoutUsers_staffInput>
    connectOrCreate?: Roles_StaffCreateOrConnectWithoutUsers_staffInput
    upsert?: Roles_StaffUpsertWithoutUsers_staffInput
    connect?: Roles_StaffWhereUniqueInput
    update?: XOR<XOR<Roles_StaffUpdateToOneWithWhereWithoutUsers_staffInput, Roles_StaffUpdateWithoutUsers_staffInput>, Roles_StaffUncheckedUpdateWithoutUsers_staffInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedEnumStatus_BrandFilter<$PrismaModel = never> = {
    equals?: $Enums.Status_Brand | EnumStatus_BrandFieldRefInput<$PrismaModel>
    in?: $Enums.Status_Brand[] | ListEnumStatus_BrandFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status_Brand[] | ListEnumStatus_BrandFieldRefInput<$PrismaModel>
    not?: NestedEnumStatus_BrandFilter<$PrismaModel> | $Enums.Status_Brand
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedEnumStatus_BrandWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status_Brand | EnumStatus_BrandFieldRefInput<$PrismaModel>
    in?: $Enums.Status_Brand[] | ListEnumStatus_BrandFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status_Brand[] | ListEnumStatus_BrandFieldRefInput<$PrismaModel>
    not?: NestedEnumStatus_BrandWithAggregatesFilter<$PrismaModel> | $Enums.Status_Brand
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatus_BrandFilter<$PrismaModel>
    _max?: NestedEnumStatus_BrandFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type Owners_BrandCreateWithoutBrandInput = {
    id_owners_brand?: string
    createdAt?: Date | string
    user_admin: Users_AdminCreateNestedOneWithoutOwners_brandInput
  }

  export type Owners_BrandUncheckedCreateWithoutBrandInput = {
    id_owners_brand?: string
    id_user_admin: string
    createdAt?: Date | string
  }

  export type Owners_BrandCreateOrConnectWithoutBrandInput = {
    where: Owners_BrandWhereUniqueInput
    create: XOR<Owners_BrandCreateWithoutBrandInput, Owners_BrandUncheckedCreateWithoutBrandInput>
  }

  export type Owners_BrandCreateManyBrandInputEnvelope = {
    data: Owners_BrandCreateManyBrandInput | Owners_BrandCreateManyBrandInput[]
  }

  export type Owners_BrandUpsertWithWhereUniqueWithoutBrandInput = {
    where: Owners_BrandWhereUniqueInput
    update: XOR<Owners_BrandUpdateWithoutBrandInput, Owners_BrandUncheckedUpdateWithoutBrandInput>
    create: XOR<Owners_BrandCreateWithoutBrandInput, Owners_BrandUncheckedCreateWithoutBrandInput>
  }

  export type Owners_BrandUpdateWithWhereUniqueWithoutBrandInput = {
    where: Owners_BrandWhereUniqueInput
    data: XOR<Owners_BrandUpdateWithoutBrandInput, Owners_BrandUncheckedUpdateWithoutBrandInput>
  }

  export type Owners_BrandUpdateManyWithWhereWithoutBrandInput = {
    where: Owners_BrandScalarWhereInput
    data: XOR<Owners_BrandUpdateManyMutationInput, Owners_BrandUncheckedUpdateManyWithoutBrandInput>
  }

  export type Owners_BrandScalarWhereInput = {
    AND?: Owners_BrandScalarWhereInput | Owners_BrandScalarWhereInput[]
    OR?: Owners_BrandScalarWhereInput[]
    NOT?: Owners_BrandScalarWhereInput | Owners_BrandScalarWhereInput[]
    id_owners_brand?: StringFilter<"Owners_Brand"> | string
    id_brand?: StringFilter<"Owners_Brand"> | string
    id_user_admin?: StringFilter<"Owners_Brand"> | string
    createdAt?: DateTimeFilter<"Owners_Brand"> | Date | string
  }

  export type Users_AdminCreateWithoutOwners_brandInput = {
    id_user_admin?: string
    id_ud: string
    user_name: string
    name?: string | null
    email: string
    phone?: string | null
    password_hash: string
    google_id?: string | null
    gender: $Enums.Gender
    date_of_birth: Date | string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: Roles_AdminCreateNestedOneWithoutUsers_adminInput
  }

  export type Users_AdminUncheckedCreateWithoutOwners_brandInput = {
    id_user_admin?: string
    id_ud: string
    user_name: string
    name?: string | null
    email: string
    phone?: string | null
    password_hash: string
    google_id?: string | null
    gender: $Enums.Gender
    date_of_birth: Date | string
    avatar?: string | null
    id_role_admin: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Users_AdminCreateOrConnectWithoutOwners_brandInput = {
    where: Users_AdminWhereUniqueInput
    create: XOR<Users_AdminCreateWithoutOwners_brandInput, Users_AdminUncheckedCreateWithoutOwners_brandInput>
  }

  export type BrandsCreateWithoutOwners_brandInput = {
    id_brand?: string
    id_b: string
    name: string
    description?: string | null
    logo?: string | null
    status?: $Enums.Status_Brand
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BrandsUncheckedCreateWithoutOwners_brandInput = {
    id_brand?: string
    id_b: string
    name: string
    description?: string | null
    logo?: string | null
    status?: $Enums.Status_Brand
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BrandsCreateOrConnectWithoutOwners_brandInput = {
    where: BrandsWhereUniqueInput
    create: XOR<BrandsCreateWithoutOwners_brandInput, BrandsUncheckedCreateWithoutOwners_brandInput>
  }

  export type Users_AdminUpsertWithoutOwners_brandInput = {
    update: XOR<Users_AdminUpdateWithoutOwners_brandInput, Users_AdminUncheckedUpdateWithoutOwners_brandInput>
    create: XOR<Users_AdminCreateWithoutOwners_brandInput, Users_AdminUncheckedCreateWithoutOwners_brandInput>
    where?: Users_AdminWhereInput
  }

  export type Users_AdminUpdateToOneWithWhereWithoutOwners_brandInput = {
    where?: Users_AdminWhereInput
    data: XOR<Users_AdminUpdateWithoutOwners_brandInput, Users_AdminUncheckedUpdateWithoutOwners_brandInput>
  }

  export type Users_AdminUpdateWithoutOwners_brandInput = {
    id_ud?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: Roles_AdminUpdateOneRequiredWithoutUsers_adminNestedInput
  }

  export type Users_AdminUncheckedUpdateWithoutOwners_brandInput = {
    id_ud?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    id_role_admin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandsUpsertWithoutOwners_brandInput = {
    update: XOR<BrandsUpdateWithoutOwners_brandInput, BrandsUncheckedUpdateWithoutOwners_brandInput>
    create: XOR<BrandsCreateWithoutOwners_brandInput, BrandsUncheckedCreateWithoutOwners_brandInput>
    where?: BrandsWhereInput
  }

  export type BrandsUpdateToOneWithWhereWithoutOwners_brandInput = {
    where?: BrandsWhereInput
    data: XOR<BrandsUpdateWithoutOwners_brandInput, BrandsUncheckedUpdateWithoutOwners_brandInput>
  }

  export type BrandsUpdateWithoutOwners_brandInput = {
    id_b?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatus_BrandFieldUpdateOperationsInput | $Enums.Status_Brand
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandsUncheckedUpdateWithoutOwners_brandInput = {
    id_b?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatus_BrandFieldUpdateOperationsInput | $Enums.Status_Brand
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Users_AdminCreateWithoutRoleInput = {
    id_user_admin?: string
    id_ud: string
    user_name: string
    name?: string | null
    email: string
    phone?: string | null
    password_hash: string
    google_id?: string | null
    gender: $Enums.Gender
    date_of_birth: Date | string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owners_brand?: Owners_BrandCreateNestedManyWithoutUser_adminInput
  }

  export type Users_AdminUncheckedCreateWithoutRoleInput = {
    id_user_admin?: string
    id_ud: string
    user_name: string
    name?: string | null
    email: string
    phone?: string | null
    password_hash: string
    google_id?: string | null
    gender: $Enums.Gender
    date_of_birth: Date | string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owners_brand?: Owners_BrandUncheckedCreateNestedManyWithoutUser_adminInput
  }

  export type Users_AdminCreateOrConnectWithoutRoleInput = {
    where: Users_AdminWhereUniqueInput
    create: XOR<Users_AdminCreateWithoutRoleInput, Users_AdminUncheckedCreateWithoutRoleInput>
  }

  export type Users_AdminCreateManyRoleInputEnvelope = {
    data: Users_AdminCreateManyRoleInput | Users_AdminCreateManyRoleInput[]
  }

  export type Users_AdminUpsertWithWhereUniqueWithoutRoleInput = {
    where: Users_AdminWhereUniqueInput
    update: XOR<Users_AdminUpdateWithoutRoleInput, Users_AdminUncheckedUpdateWithoutRoleInput>
    create: XOR<Users_AdminCreateWithoutRoleInput, Users_AdminUncheckedCreateWithoutRoleInput>
  }

  export type Users_AdminUpdateWithWhereUniqueWithoutRoleInput = {
    where: Users_AdminWhereUniqueInput
    data: XOR<Users_AdminUpdateWithoutRoleInput, Users_AdminUncheckedUpdateWithoutRoleInput>
  }

  export type Users_AdminUpdateManyWithWhereWithoutRoleInput = {
    where: Users_AdminScalarWhereInput
    data: XOR<Users_AdminUpdateManyMutationInput, Users_AdminUncheckedUpdateManyWithoutRoleInput>
  }

  export type Users_AdminScalarWhereInput = {
    AND?: Users_AdminScalarWhereInput | Users_AdminScalarWhereInput[]
    OR?: Users_AdminScalarWhereInput[]
    NOT?: Users_AdminScalarWhereInput | Users_AdminScalarWhereInput[]
    id_user_admin?: StringFilter<"Users_Admin"> | string
    id_ud?: StringFilter<"Users_Admin"> | string
    user_name?: StringFilter<"Users_Admin"> | string
    name?: StringNullableFilter<"Users_Admin"> | string | null
    email?: StringFilter<"Users_Admin"> | string
    phone?: StringNullableFilter<"Users_Admin"> | string | null
    password_hash?: StringFilter<"Users_Admin"> | string
    google_id?: StringNullableFilter<"Users_Admin"> | string | null
    gender?: EnumGenderFilter<"Users_Admin"> | $Enums.Gender
    date_of_birth?: DateTimeFilter<"Users_Admin"> | Date | string
    avatar?: StringNullableFilter<"Users_Admin"> | string | null
    id_role_admin?: StringFilter<"Users_Admin"> | string
    createdAt?: DateTimeFilter<"Users_Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Users_Admin"> | Date | string
  }

  export type Users_KhachHangCreateWithoutRoleInput = {
    id_user_KhachHang?: string
    id_uk: string
    user_name: string
    name?: string | null
    email: string
    phone?: string | null
    google_id?: string | null
    gender: $Enums.Gender
    date_of_birth: Date | string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Users_KhachHangUncheckedCreateWithoutRoleInput = {
    id_user_KhachHang?: string
    id_uk: string
    user_name: string
    name?: string | null
    email: string
    phone?: string | null
    google_id?: string | null
    gender: $Enums.Gender
    date_of_birth: Date | string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Users_KhachHangCreateOrConnectWithoutRoleInput = {
    where: Users_KhachHangWhereUniqueInput
    create: XOR<Users_KhachHangCreateWithoutRoleInput, Users_KhachHangUncheckedCreateWithoutRoleInput>
  }

  export type Users_KhachHangCreateManyRoleInputEnvelope = {
    data: Users_KhachHangCreateManyRoleInput | Users_KhachHangCreateManyRoleInput[]
  }

  export type Users_KhachHangUpsertWithWhereUniqueWithoutRoleInput = {
    where: Users_KhachHangWhereUniqueInput
    update: XOR<Users_KhachHangUpdateWithoutRoleInput, Users_KhachHangUncheckedUpdateWithoutRoleInput>
    create: XOR<Users_KhachHangCreateWithoutRoleInput, Users_KhachHangUncheckedCreateWithoutRoleInput>
  }

  export type Users_KhachHangUpdateWithWhereUniqueWithoutRoleInput = {
    where: Users_KhachHangWhereUniqueInput
    data: XOR<Users_KhachHangUpdateWithoutRoleInput, Users_KhachHangUncheckedUpdateWithoutRoleInput>
  }

  export type Users_KhachHangUpdateManyWithWhereWithoutRoleInput = {
    where: Users_KhachHangScalarWhereInput
    data: XOR<Users_KhachHangUpdateManyMutationInput, Users_KhachHangUncheckedUpdateManyWithoutRoleInput>
  }

  export type Users_KhachHangScalarWhereInput = {
    AND?: Users_KhachHangScalarWhereInput | Users_KhachHangScalarWhereInput[]
    OR?: Users_KhachHangScalarWhereInput[]
    NOT?: Users_KhachHangScalarWhereInput | Users_KhachHangScalarWhereInput[]
    id_user_KhachHang?: StringFilter<"Users_KhachHang"> | string
    id_uk?: StringFilter<"Users_KhachHang"> | string
    user_name?: StringFilter<"Users_KhachHang"> | string
    name?: StringNullableFilter<"Users_KhachHang"> | string | null
    email?: StringFilter<"Users_KhachHang"> | string
    phone?: StringNullableFilter<"Users_KhachHang"> | string | null
    google_id?: StringNullableFilter<"Users_KhachHang"> | string | null
    gender?: EnumGenderFilter<"Users_KhachHang"> | $Enums.Gender
    date_of_birth?: DateTimeFilter<"Users_KhachHang"> | Date | string
    avatar?: StringNullableFilter<"Users_KhachHang"> | string | null
    createdAt?: DateTimeFilter<"Users_KhachHang"> | Date | string
    updatedAt?: DateTimeFilter<"Users_KhachHang"> | Date | string
    id_role_KhachHang?: StringFilter<"Users_KhachHang"> | string
  }

  export type Users_StaffCreateWithoutRoleInput = {
    id_user_staff?: string
    id_ut: string
    user_name: string
    name?: string | null
    email: string
    phone?: string | null
    google_id?: string | null
    gender: $Enums.Gender
    date_of_birth: Date | string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Users_StaffUncheckedCreateWithoutRoleInput = {
    id_user_staff?: string
    id_ut: string
    user_name: string
    name?: string | null
    email: string
    phone?: string | null
    google_id?: string | null
    gender: $Enums.Gender
    date_of_birth: Date | string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Users_StaffCreateOrConnectWithoutRoleInput = {
    where: Users_StaffWhereUniqueInput
    create: XOR<Users_StaffCreateWithoutRoleInput, Users_StaffUncheckedCreateWithoutRoleInput>
  }

  export type Users_StaffCreateManyRoleInputEnvelope = {
    data: Users_StaffCreateManyRoleInput | Users_StaffCreateManyRoleInput[]
  }

  export type Users_StaffUpsertWithWhereUniqueWithoutRoleInput = {
    where: Users_StaffWhereUniqueInput
    update: XOR<Users_StaffUpdateWithoutRoleInput, Users_StaffUncheckedUpdateWithoutRoleInput>
    create: XOR<Users_StaffCreateWithoutRoleInput, Users_StaffUncheckedCreateWithoutRoleInput>
  }

  export type Users_StaffUpdateWithWhereUniqueWithoutRoleInput = {
    where: Users_StaffWhereUniqueInput
    data: XOR<Users_StaffUpdateWithoutRoleInput, Users_StaffUncheckedUpdateWithoutRoleInput>
  }

  export type Users_StaffUpdateManyWithWhereWithoutRoleInput = {
    where: Users_StaffScalarWhereInput
    data: XOR<Users_StaffUpdateManyMutationInput, Users_StaffUncheckedUpdateManyWithoutRoleInput>
  }

  export type Users_StaffScalarWhereInput = {
    AND?: Users_StaffScalarWhereInput | Users_StaffScalarWhereInput[]
    OR?: Users_StaffScalarWhereInput[]
    NOT?: Users_StaffScalarWhereInput | Users_StaffScalarWhereInput[]
    id_user_staff?: StringFilter<"Users_Staff"> | string
    id_ut?: StringFilter<"Users_Staff"> | string
    user_name?: StringFilter<"Users_Staff"> | string
    name?: StringNullableFilter<"Users_Staff"> | string | null
    email?: StringFilter<"Users_Staff"> | string
    phone?: StringNullableFilter<"Users_Staff"> | string | null
    google_id?: StringNullableFilter<"Users_Staff"> | string | null
    gender?: EnumGenderFilter<"Users_Staff"> | $Enums.Gender
    date_of_birth?: DateTimeFilter<"Users_Staff"> | Date | string
    avatar?: StringNullableFilter<"Users_Staff"> | string | null
    createdAt?: DateTimeFilter<"Users_Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Users_Staff"> | Date | string
    id_role_staff?: StringFilter<"Users_Staff"> | string
  }

  export type Roles_AdminCreateWithoutUsers_adminInput = {
    id_role_admin?: string
    id_ra: string
    name: string
    description?: string | null
  }

  export type Roles_AdminUncheckedCreateWithoutUsers_adminInput = {
    id_role_admin?: string
    id_ra: string
    name: string
    description?: string | null
  }

  export type Roles_AdminCreateOrConnectWithoutUsers_adminInput = {
    where: Roles_AdminWhereUniqueInput
    create: XOR<Roles_AdminCreateWithoutUsers_adminInput, Roles_AdminUncheckedCreateWithoutUsers_adminInput>
  }

  export type Owners_BrandCreateWithoutUser_adminInput = {
    id_owners_brand?: string
    createdAt?: Date | string
    brand: BrandsCreateNestedOneWithoutOwners_brandInput
  }

  export type Owners_BrandUncheckedCreateWithoutUser_adminInput = {
    id_owners_brand?: string
    id_brand: string
    createdAt?: Date | string
  }

  export type Owners_BrandCreateOrConnectWithoutUser_adminInput = {
    where: Owners_BrandWhereUniqueInput
    create: XOR<Owners_BrandCreateWithoutUser_adminInput, Owners_BrandUncheckedCreateWithoutUser_adminInput>
  }

  export type Owners_BrandCreateManyUser_adminInputEnvelope = {
    data: Owners_BrandCreateManyUser_adminInput | Owners_BrandCreateManyUser_adminInput[]
  }

  export type Roles_AdminUpsertWithoutUsers_adminInput = {
    update: XOR<Roles_AdminUpdateWithoutUsers_adminInput, Roles_AdminUncheckedUpdateWithoutUsers_adminInput>
    create: XOR<Roles_AdminCreateWithoutUsers_adminInput, Roles_AdminUncheckedCreateWithoutUsers_adminInput>
    where?: Roles_AdminWhereInput
  }

  export type Roles_AdminUpdateToOneWithWhereWithoutUsers_adminInput = {
    where?: Roles_AdminWhereInput
    data: XOR<Roles_AdminUpdateWithoutUsers_adminInput, Roles_AdminUncheckedUpdateWithoutUsers_adminInput>
  }

  export type Roles_AdminUpdateWithoutUsers_adminInput = {
    id_ra?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Roles_AdminUncheckedUpdateWithoutUsers_adminInput = {
    id_ra?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Owners_BrandUpsertWithWhereUniqueWithoutUser_adminInput = {
    where: Owners_BrandWhereUniqueInput
    update: XOR<Owners_BrandUpdateWithoutUser_adminInput, Owners_BrandUncheckedUpdateWithoutUser_adminInput>
    create: XOR<Owners_BrandCreateWithoutUser_adminInput, Owners_BrandUncheckedCreateWithoutUser_adminInput>
  }

  export type Owners_BrandUpdateWithWhereUniqueWithoutUser_adminInput = {
    where: Owners_BrandWhereUniqueInput
    data: XOR<Owners_BrandUpdateWithoutUser_adminInput, Owners_BrandUncheckedUpdateWithoutUser_adminInput>
  }

  export type Owners_BrandUpdateManyWithWhereWithoutUser_adminInput = {
    where: Owners_BrandScalarWhereInput
    data: XOR<Owners_BrandUpdateManyMutationInput, Owners_BrandUncheckedUpdateManyWithoutUser_adminInput>
  }

  export type Roles_KhachHangCreateWithoutUsers_khachhangInput = {
    id_role_KhachHang?: string
    id_rkh: string
    name: string
    description?: string | null
  }

  export type Roles_KhachHangUncheckedCreateWithoutUsers_khachhangInput = {
    id_role_KhachHang?: string
    id_rkh: string
    name: string
    description?: string | null
  }

  export type Roles_KhachHangCreateOrConnectWithoutUsers_khachhangInput = {
    where: Roles_KhachHangWhereUniqueInput
    create: XOR<Roles_KhachHangCreateWithoutUsers_khachhangInput, Roles_KhachHangUncheckedCreateWithoutUsers_khachhangInput>
  }

  export type Roles_KhachHangUpsertWithoutUsers_khachhangInput = {
    update: XOR<Roles_KhachHangUpdateWithoutUsers_khachhangInput, Roles_KhachHangUncheckedUpdateWithoutUsers_khachhangInput>
    create: XOR<Roles_KhachHangCreateWithoutUsers_khachhangInput, Roles_KhachHangUncheckedCreateWithoutUsers_khachhangInput>
    where?: Roles_KhachHangWhereInput
  }

  export type Roles_KhachHangUpdateToOneWithWhereWithoutUsers_khachhangInput = {
    where?: Roles_KhachHangWhereInput
    data: XOR<Roles_KhachHangUpdateWithoutUsers_khachhangInput, Roles_KhachHangUncheckedUpdateWithoutUsers_khachhangInput>
  }

  export type Roles_KhachHangUpdateWithoutUsers_khachhangInput = {
    id_rkh?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Roles_KhachHangUncheckedUpdateWithoutUsers_khachhangInput = {
    id_rkh?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Roles_StaffCreateWithoutUsers_staffInput = {
    id_role_staff?: string
    id_rt: string
    name: string
    description?: string | null
  }

  export type Roles_StaffUncheckedCreateWithoutUsers_staffInput = {
    id_role_staff?: string
    id_rt: string
    name: string
    description?: string | null
  }

  export type Roles_StaffCreateOrConnectWithoutUsers_staffInput = {
    where: Roles_StaffWhereUniqueInput
    create: XOR<Roles_StaffCreateWithoutUsers_staffInput, Roles_StaffUncheckedCreateWithoutUsers_staffInput>
  }

  export type Roles_StaffUpsertWithoutUsers_staffInput = {
    update: XOR<Roles_StaffUpdateWithoutUsers_staffInput, Roles_StaffUncheckedUpdateWithoutUsers_staffInput>
    create: XOR<Roles_StaffCreateWithoutUsers_staffInput, Roles_StaffUncheckedCreateWithoutUsers_staffInput>
    where?: Roles_StaffWhereInput
  }

  export type Roles_StaffUpdateToOneWithWhereWithoutUsers_staffInput = {
    where?: Roles_StaffWhereInput
    data: XOR<Roles_StaffUpdateWithoutUsers_staffInput, Roles_StaffUncheckedUpdateWithoutUsers_staffInput>
  }

  export type Roles_StaffUpdateWithoutUsers_staffInput = {
    id_rt?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Roles_StaffUncheckedUpdateWithoutUsers_staffInput = {
    id_rt?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Owners_BrandCreateManyBrandInput = {
    id_owners_brand?: string
    id_user_admin: string
    createdAt?: Date | string
  }

  export type Owners_BrandUpdateWithoutBrandInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_admin?: Users_AdminUpdateOneRequiredWithoutOwners_brandNestedInput
  }

  export type Owners_BrandUncheckedUpdateWithoutBrandInput = {
    id_user_admin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Owners_BrandUncheckedUpdateManyWithoutBrandInput = {
    id_user_admin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Users_AdminCreateManyRoleInput = {
    id_user_admin?: string
    id_ud: string
    user_name: string
    name?: string | null
    email: string
    phone?: string | null
    password_hash: string
    google_id?: string | null
    gender: $Enums.Gender
    date_of_birth: Date | string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Users_AdminUpdateWithoutRoleInput = {
    id_ud?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owners_brand?: Owners_BrandUpdateManyWithoutUser_adminNestedInput
  }

  export type Users_AdminUncheckedUpdateWithoutRoleInput = {
    id_ud?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owners_brand?: Owners_BrandUncheckedUpdateManyWithoutUser_adminNestedInput
  }

  export type Users_AdminUncheckedUpdateManyWithoutRoleInput = {
    id_ud?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Users_KhachHangCreateManyRoleInput = {
    id_user_KhachHang?: string
    id_uk: string
    user_name: string
    name?: string | null
    email: string
    phone?: string | null
    google_id?: string | null
    gender: $Enums.Gender
    date_of_birth: Date | string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Users_KhachHangUpdateWithoutRoleInput = {
    id_uk?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Users_KhachHangUncheckedUpdateWithoutRoleInput = {
    id_uk?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Users_KhachHangUncheckedUpdateManyWithoutRoleInput = {
    id_uk?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Users_StaffCreateManyRoleInput = {
    id_user_staff?: string
    id_ut: string
    user_name: string
    name?: string | null
    email: string
    phone?: string | null
    google_id?: string | null
    gender: $Enums.Gender
    date_of_birth: Date | string
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Users_StaffUpdateWithoutRoleInput = {
    id_ut?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Users_StaffUncheckedUpdateWithoutRoleInput = {
    id_ut?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Users_StaffUncheckedUpdateManyWithoutRoleInput = {
    id_ut?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Owners_BrandCreateManyUser_adminInput = {
    id_owners_brand?: string
    id_brand: string
    createdAt?: Date | string
  }

  export type Owners_BrandUpdateWithoutUser_adminInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: BrandsUpdateOneRequiredWithoutOwners_brandNestedInput
  }

  export type Owners_BrandUncheckedUpdateWithoutUser_adminInput = {
    id_brand?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Owners_BrandUncheckedUpdateManyWithoutUser_adminInput = {
    id_brand?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use BrandsCountOutputTypeDefaultArgs instead
     */
    export type BrandsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BrandsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Roles_AdminCountOutputTypeDefaultArgs instead
     */
    export type Roles_AdminCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Roles_AdminCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Roles_KhachHangCountOutputTypeDefaultArgs instead
     */
    export type Roles_KhachHangCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Roles_KhachHangCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Roles_StaffCountOutputTypeDefaultArgs instead
     */
    export type Roles_StaffCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Roles_StaffCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Users_AdminCountOutputTypeDefaultArgs instead
     */
    export type Users_AdminCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Users_AdminCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BrandsDefaultArgs instead
     */
    export type BrandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BrandsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Owners_BrandDefaultArgs instead
     */
    export type Owners_BrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Owners_BrandDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Roles_AdminDefaultArgs instead
     */
    export type Roles_AdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Roles_AdminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Roles_KhachHangDefaultArgs instead
     */
    export type Roles_KhachHangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Roles_KhachHangDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Roles_StaffDefaultArgs instead
     */
    export type Roles_StaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Roles_StaffDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Users_AdminDefaultArgs instead
     */
    export type Users_AdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Users_AdminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Users_KhachHangDefaultArgs instead
     */
    export type Users_KhachHangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Users_KhachHangDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Users_StaffDefaultArgs instead
     */
    export type Users_StaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Users_StaffDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}